# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type AnswerAttributes {
    answerId: [Int!]!
    delayRequirements: [BigInt!]!
    heroClass: [Int!]!
    id: ID!
    isFinalAnswer: [Boolean!]!
    pageId: [Int!]!
    randomRequirements: [BigInt!]!
}

type AnswerBurnRandomItemMeta {
    answerId: [Int!]!
    chances: [String!]!
    heroClass: [Int!]!
    id: ID!
    isStopIfBurnt: [String!]!
    pageId: [Int!]!
    slots: [String!]!
}

type AttackInfoEntity {
    attackToken: ItemEntity
    attackType: Int!
    id: ID!
    skillTokens(first: Int = 100, orderBy: ItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemEntity_filter): [ItemEntity!]!
}

type AttributeGenerateInfo {
    id: ID!
    ids: [Int!]!
    values: [Int!]!
}

type BurnHistoryEntity {
    burn: BigInt!
    id: ID!
    timestamp: BigInt!
    token: TokenEntity!
}

type ChamberActionResultEntity {
    chamber: OpenedChamberEntity!
    completed: Boolean
    damage: Int!
    data: String!
    experience: Int!
    fightResult(first: Int = 100, orderBy: FightResultEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FightResultEntity_filter): [FightResultEntity!]!
    heal: Int!
    id: ID!
    itemsBurnt(first: Int = 100, orderBy: ItemsBurntResultEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemsBurntResultEntity_filter): [ItemsBurntResultEntity!]
    kill: Boolean
    lifeChancesRecovered: Int!
    manaConsumed: Int!
    manaRegen: Int!
    mintItems(first: Int = 100, orderBy: ItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemEntity_filter): [ItemEntity!]!
    storyResult(first: Int = 100, orderBy: StoryResultEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StoryResultEntity_filter): [StoryResultEntity!]!
    turn: Int!
}

type ChamberEntity {
    biome: Int!
    chamberName: String!
    chamberSymbol: String!
    chamberType: Int!
    controller: ControllerEntity!
    id: ID!
    isBattle: Boolean!
    isEvent: Boolean!
    isStory: Boolean!
    openedChambers(first: Int = 100, orderBy: OpenedChamberEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: OpenedChamberEntity_filter): [OpenedChamberEntity!]!
    uri: String!
    valid: Boolean!
}

type ControllableEntity {
    controller: String!
    createdBlock: Int!
    createdTs: Int!
    id: ID!
}

type ControllerEntity {
    controllable: ControllableEntity!
    dungeonFactory: String!
    fightDelay: Int!
    gameObjectController: String!
    gameToken: String!
    governance: String!
    heroController: String!
    heroes(first: Int = 100, orderBy: HeroMetaEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroMetaEntity_filter): [HeroMetaEntity!]!
    "Central contract for storing all dependency addresses"
    id: ID!
    itemController: String!
    items(first: Int = 100, orderBy: ItemMetaEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemMetaEntity_filter): [ItemMetaEntity!]!
    oracle: String!
    registeredNames(first: Int = 100, orderBy: RegisteredNameEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: RegisteredNameEntity_filter): [RegisteredNameEntity!]!
    reinforcementController: String!
    statController: String!
    storyController: String!
    treasury: TreasuryEntity!
    treasuryTokenInfo(first: Int = 100, orderBy: TreasuryTokenInfoEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TreasuryTokenInfoEntity_filter): [TreasuryTokenInfoEntity!]!
}

type CoreAttributesEntity {
    dexterity: Int!
    energy: Int!
    id: ID!
    strength: Int!
    vitality: Int!
}

type DAUStatisticEntity {
    count: Int!
    id: ID!
    users(first: Int = 100, orderBy: UserEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: UserEntity_filter): [UserEntity!]!
}

type DungeonChamberMeta {
    chamberChance: BigDecimal!
    chamberType: Int!
    dungeon: DungeonLogicEntity!
    id: ID!
    uniqChamber: ChamberEntity
}

type DungeonEntity {
    claimedItems(first: Int = 100, orderBy: HeroItemEarned_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroItemEarned_filter): [HeroItemEarned!]!
    claimedTokens(first: Int = 100, orderBy: HeroTokenEarned_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroTokenEarned_filter): [HeroTokenEarned!]!
    currentChamber: OpenedChamberEntity
    currentChamberIndex: Int!
    enteredHero: HeroEntity
    factory: DungeonFactoryEntity!
    id: ID!
    isCompleted: Boolean!
    logic: DungeonLogicEntity!
    treasuryItems(first: Int = 100, orderBy: ItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemEntity_filter): [ItemEntity!]!
    treasuryTokens(first: Int = 100, orderBy: DungeonTreasuryTokenEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonTreasuryTokenEntity_filter): [DungeonTreasuryTokenEntity!]!
    valid: Boolean!
}

type DungeonFactoryEntity {
    controllable: ControllableEntity!
    controller: ControllerEntity!
    dungeonLogics(first: Int = 100, orderBy: DungeonLogicEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonLogicEntity_filter): [DungeonLogicEntity!]!
    dungeons(first: Int = 100, orderBy: DungeonEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonEntity_filter): [DungeonEntity!]!
    id: ID!
}

type DungeonLogicEntity {
    biome: Int!
    chambersMeta(first: Int = 100, orderBy: DungeonChamberMeta_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonChamberMeta_filter): [DungeonChamberMeta!]!
    dungeons(first: Int = 100, orderBy: DungeonEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonEntity_filter): [DungeonEntity!]!
    factory: DungeonFactoryEntity!
    id: ID!
    maxLevel: Int!
    minLevel: Int!
    requirements(first: Int = 100, orderBy: DungeonRequirements_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonRequirements_filter): [DungeonRequirements!]!
    specificClass: Int!
    specificLvl: Int!
    stages: Int!
    valid: Boolean!
}

type DungeonRequirements {
    dataIndex: String!
    id: ID!
    isHeroData: Boolean!
    logic: DungeonLogicEntity!
    maxValue: Int!
    minValue: Int!
}

type DungeonRunCounterEntity {
    count: Int!
    id: ID!
}

type DungeonTreasuryTokenEntity {
    dungeon: DungeonEntity!
    id: ID!
    token: TokenAmountEntity!
}

type EventGenerateInfoData {
    badAttributes: AttributeGenerateInfo!
    biome: Int!
    damage: Int!
    eventId: Int!
    experience: BigInt!
    goodAttributes: AttributeGenerateInfo!
    goodChance: BigInt!
    heal: Int!
    id: ID!
    lifeChancesRecovered: Int!
    manaConsumed: Int!
    manaRegen: Int!
    mintItems: [String!]!
    mintItemsChances: [BigInt!]!
    subType: Int!
}

type EventGenerateInfoNegativeStatData {
    damage: BigInt
    id: ID!
    manaConsumed: BigInt
}

type EventGenerateInfoPositiveStatData {
    experience: BigInt
    heal: BigInt
    id: ID!
    lifeChancesRecovered: BigInt
    manaRegen: BigInt
}

type EventResultEntity {
    damage: Int!
    experience: Int!
    heal: Int!
    id: ID!
    lifeChancesRecovered: Int!
    manaConsumed: Int!
    manaRegen: Int!
    negAttributes: [BigDecimal!]!
    posAttributes: [BigDecimal!]!
}

type FightResultEntity {
    fighterA: FighterTurnResultEntity!
    fighterB: FighterTurnResultEntity!
    id: ID!
    result: ChamberActionResultEntity!
}

type FighterInfoEntity {
    attackToken: ItemEntity
    attackType: Int!
    fighterAttributes: [BigDecimal!]!
    fighterStats: StatsEntity!
    id: ID!
    race: Int!
}

type FighterTurnResultEntity {
    damage: Int!
    damagePoison: Int!
    damageReflect: Int!
    health: Int!
    id: ID!
    info: FighterInfoEntity!
    magicAttack: ItemMagicAttackInfoEntity!
    manaConsumed: Int!
    statuses: StatusesEntity!
}

type GeneralHeroTokenEarned {
    countAmount: Int!
    countReinforcementRewards: Int!
    id: ID!
    totalAmount: BigInt!
    totalReinforcementRewards: BigDecimal!
}

type GeneralTokenomicsEntity {
    heroes: Int!
    heroesByClass: [Int!]!
    id: ID!
    liveHeroes: Int!
    liveHeroesByClass: [Int!]!
    spentOnHero: BigDecimal!
    spentOnItems: BigDecimal!
    totalBurned: BigInt!
    totalMinted: BigInt!
    users: Int!
}

type GlobalCustomDataEntity {
    id: ID!
    value: BigDecimal!
}

type HeroAction {
    action: Int!
    hero: HeroEntity!
    id: ID!
    owner: UserEntity!
    timestamp: BigInt!
    values: [String!]!
}

type HeroCustomData {
    dataIndex: String!
    hero: HeroEntity!
    id: ID!
    value: BigDecimal!
}

type HeroEntity {
    actions(first: Int = 100, orderBy: HeroAction_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroAction_filter): [HeroAction!]!
    attributes: [BigDecimal!]!
    biome: Int!
    burned: Boolean!
    core: CoreAttributesEntity!
    customData(first: Int = 100, orderBy: HeroCustomData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroCustomData_filter): [HeroCustomData!]!
    dead: Boolean!
    dungeon: DungeonEntity
    earnedItems(first: Int = 100, orderBy: HeroItemEarned_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroItemEarned_filter): [HeroItemEarned!]!
    earnedTokens(first: Int = 100, orderBy: HeroTokenEarned_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroTokenEarned_filter): [HeroTokenEarned!]!
    heroId: Int!
    heroStat: HeroStatEntity!
    id: ID!
    items(first: Int = 100, orderBy: ItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemEntity_filter): [ItemEntity!]!
    lastFightTs: Int!
    lastTransfer: Int!
    maxBiomeCompleted: Int!
    meta: HeroMetaEntity!
    nextLevelExperienceRequire: Int!
    openedChambers(first: Int = 100, orderBy: OpenedChamberEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: OpenedChamberEntity_filter): [OpenedChamberEntity!]!
    owner: UserEntity!
    previousLevelExperienceRequire: Int!
    refCode: String
    reinforcementHelper: HeroEntity
    reinforcementRewardItems(first: Int = 100, orderBy: ReinforcementRewardItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ReinforcementRewardItemEntity_filter): [ReinforcementRewardItemEntity!]!
    reinforcementRewardTokens(first: Int = 100, orderBy: ReinforcementRewardTokenEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ReinforcementRewardTokenEntity_filter): [ReinforcementRewardTokenEntity!]!
    score: Int!
    staked: Boolean!
    stakedFee: Int!
    stats: StatsEntity!
    timestamp: BigInt!
    uniqName: String!
    uniqUri: String
}

type HeroItemEarned {
    dungeon: DungeonEntity!
    hero: HeroEntity!
    id: ID!
    item: ItemEntity!
    timestamp: BigInt!
}

type HeroMetaEntity {
    controllable: ControllableEntity!
    controller: ControllerEntity!
    feeToken: TokenAmountEntity!
    heroClass: Int!
    id: ID!
    initialAttributes: CoreAttributesEntity!
    name: String!
    symbol: String!
    uri: String!
    valid: Boolean!
}

type HeroStatEntity {
    battles: Int!
    dungeonCompleted: Int!
    events: Int!
    hero: HeroEntity!
    id: ID!
    itemsMinted: Int!
    reinforcementTokenEarned: BigInt!
    stories: Int!
    tokenEarned: BigInt!
}

type HeroTokenEarned {
    amount: BigInt!
    dungeon: DungeonEntity!
    hero: HeroEntity
    id: ID!
    reinforcementStakedFee: Int!
    timestamp: BigInt!
    token: TokenEntity!
}

type HeroTokensVaultEntity {
    createdAtBlock: BigInt!
    id: ID!
}

type HeroTokensVaultHistoryEntity {
    amount: BigInt!
    from: UserEntity!
    id: ID!
    timestamp: BigInt!
    toBurn: BigInt!
    toGov: BigInt!
    toTreasury: BigInt!
    token: TokenEntity!
}

type HeroTokensVaultStatisticEntity {
    amount: BigInt!
    id: ID!
    toBurn: BigInt!
    toGov: BigInt!
    toTreasury: BigInt!
}

type ItemActionEntity {
    action: Int!
    id: ID!
    item: ItemEntity!
    timestamp: BigInt!
    user: UserEntity
    values: [String!]!
}

type ItemBuffInfoEntity {
    casterAttributes: [BigDecimal!]!
    id: ID!
    item: ItemEntity
    manaConsumption: Int!
    targetAttributes: [BigDecimal!]!
}

type ItemConsumableInfoEntity {
    attributes: [BigDecimal!]!
    buffStats: StatsEntity!
    id: ID!
    item: ItemEntity
}

type ItemEntity {
    actions(first: Int = 100, orderBy: ItemActionEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemActionEntity_filter): [ItemActionEntity!]!
    attributes: [BigDecimal!]!
    augmentationLevel: Int!
    buffInfo: ItemBuffInfoEntity
    burned: Boolean!
    consumableInfo: ItemConsumableInfoEntity
    dungeon: DungeonEntity
    durability: Int!
    durabilityPercent: Int!
    equipped: Boolean!
    equippedSlot: Int
    hero: HeroEntity
    id: ID!
    itemId: Int!
    magicAttackInfo: ItemMagicAttackInfoEntity
    meta: ItemMetaEntity!
    rarity: Int!
    score: Int!
    uniqUri: String
    user: UserEntity
}

type ItemMagicAttackInfoEntity {
    attackType: Int!
    attributesFactor: CoreAttributesEntity!
    id: ID!
    item: ItemEntity
    maxDmg: Int!
    minDmg: Int!
}

type ItemMetaConsumableInfoAttributeEntity {
    id: ID!
    ids: [Int!]!
    values: [Int!]!
}

type ItemMetaEntity {
    controllable: ControllableEntity!
    controller: ControllerEntity!
    durability: Int!
    feeToken: TokenAmountEntity!
    id: ID!
    isAttackItem: Boolean!
    isBuffItem: Boolean!
    isConsumableItem: Boolean!
    itemType: Int!
    level: Int!
    manaCost: Int!
    name: String!
    params: ItemMetaParamsEntity
    pawnshopItemStat(first: Int = 100, orderBy: PawnshopPositionItemStatEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PawnshopPositionItemStatEntity_filter): [PawnshopPositionItemStatEntity!]!
    removed: Boolean!
    requirements: CoreAttributesEntity!
    symbol: String!
    uri: String!
    valid: Boolean!
}

type ItemMetaGeneralParamsEntity {
    baseDurability: Int!
    defaultRarity: Int!
    id: ID!
    itemLevel: Int!
    itemMetaType: Int!
    itemType: Int!
    manaCost: BigInt!
    maxRandomAttributes: Int!
    minRandomAttributes: Int!
    requirements: CoreAttributesEntity!
}

type ItemMetaGenerateInfo {
    chances: [BigInt!]!
    id: ID!
    ids: [Int!]!
    maxs: [Int!]!
    mins: [Int!]!
}

type ItemMetaMagicAttackInfoEntity {
    aType: Int!
    attributeFactors: CoreAttributesEntity!
    id: ID!
    max: Int!
    min: Int!
}

type ItemMetaParamsEntity {
    augmentAmount: BigInt!
    augmentToken: String!
    casterAttributes: ItemMetaGenerateInfo!
    commonAttributes: ItemMetaGenerateInfo!
    consumableAttributes: ItemMetaConsumableInfoAttributeEntity!
    consumableStats: StatsMetaEntity!
    genAttackInfo: ItemMetaMagicAttackInfoEntity!
    id: ID!
    itemMeta: ItemMetaGeneralParamsEntity!
    targetAttributes: ItemMetaGenerateInfo!
}

type ItemsBurntResultEntity {
    id: ID!
    item: ItemEntity!
    result: ChamberActionResultEntity!
}

type MonsterGenerateAttackInfoData {
    attackToken: String
    attackTokenId: BigInt
    attackType: Int!
    id: ID!
    mintItems: [String!]!
    mintItemsChances: [BigInt!]!
}

type MonsterGenerateInfoData {
    attackInfo: MonsterGenerateAttackInfoData!
    biome: Int!
    experience: BigInt
    id: ID!
    ids: [Int!]!
    level: Int
    maxDropItems: Int!
    monsterId: Int!
    race: Int!
    subType: Int!
    values: [Int!]!
}

type MonsterInfoEntity {
    attackInfo: AttackInfoEntity
    currentHp: BigDecimal!
    experience: Int!
    generated: Boolean!
    id: ID!
    level: Int!
    monsterAttributes: [BigDecimal!]!
    race: Int!
    rarity: BigDecimal!
    turn: Int!
}

type MonsterMintItemData {
    id: ID!
    mintItems: [String!]!
    mintItemsChanges: [BigInt!]!
}

type OpenedChamberEntity {
    actions(first: Int = 100, orderBy: ChamberActionResultEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ChamberActionResultEntity_filter): [ChamberActionResultEntity!]!
    chamber: ChamberEntity!
    completed: Boolean!
    dungeon: DungeonEntity!
    enteredHero: HeroEntity!
    event: EventResultEntity
    heroAdr: String!
    heroId: Int!
    id: ID!
    iteration: Int!
    monster: MonsterInfoEntity
    pages(first: Int = 100, orderBy: StoryPageEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StoryPageEntity_filter): [StoryPageEntity!]!
    stage: Int!
}

type PawnshopEntity {
    feeRecipient: String!
    id: ID!
    owner: String!
    platformFee: Int!
    positionDepositAmount: BigDecimal!
    positionDepositToken: TokenEntity
    positions(first: Int = 100, orderBy: PawnshopPositionEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PawnshopPositionEntity_filter): [PawnshopPositionEntity!]!
}

type PawnshopPositionEntity {
    acquiredAmount: BigDecimal!
    acquiredToken: TokenEntity!
    actions(first: Int = 100, orderBy: PawnshopPositionHistoryEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PawnshopPositionHistoryEntity_filter): [PawnshopPositionHistoryEntity!]!
    borrower: PawnshopUserEntity
    collateralAmount: BigDecimal
    collateralHero: HeroEntity
    collateralItem: ItemEntity
    collateralNft: String
    collateralNftId: BigDecimal
    collateralToken: TokenEntity
    createdBlock: Int!
    createdTs: Int!
    depositAmount: BigDecimal
    depositToken: TokenEntity
    executionLender: PawnshopUserEntity
    executionPosEndBlock: Int
    executionPosEndTs: Int
    executionPosStartBlock: Int
    executionPosStartTs: Int
    id: ID!
    open: Boolean!
    pawnshop: PawnshopEntity!
    posDurationBlocks: Int!
    posFee: Int!
    posId: Int!
}

type PawnshopPositionHistoryEntity {
    action: Int!
    id: ID!
    item: ItemMetaEntity
    position: PawnshopPositionEntity!
    timestamp: Int!
    user: UserEntity!
    values: [String!]!
}

type PawnshopPositionItemStatEntity {
    avg: BigDecimal!
    id: ID!
    item: ItemMetaEntity!
    max: BigDecimal!
    min: BigDecimal!
    prices: [BigDecimal!]!
    totalTrades: Int!
}

type PawnshopStatisticEntity {
    avgClosePrice: BigDecimal!
    fees: BigDecimal!
    heroes: Int!
    id: ID!
    items: Int!
    maxClosePrice: BigDecimal!
    minClosePrice: BigDecimal!
    totalPosition: Int!
    volume: BigDecimal!
}

type PawnshopUserEntity {
    id: ID!
    openedPositions(first: Int = 100, orderBy: PawnshopPositionEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PawnshopPositionEntity_filter): [PawnshopPositionEntity!]!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    answerAttributes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerAttributes_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerAttributes_filter
    ): [AnswerAttributes!]!
    answerBurnRandomItemMeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AnswerBurnRandomItemMeta
    answerBurnRandomItemMetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerBurnRandomItemMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerBurnRandomItemMeta_filter
    ): [AnswerBurnRandomItemMeta!]!
    attackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AttackInfoEntity_filter
    ): [AttackInfoEntity!]!
    attackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AttackInfoEntity
    attributeGenerateInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AttributeGenerateInfo
    attributeGenerateInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AttributeGenerateInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AttributeGenerateInfo_filter
    ): [AttributeGenerateInfo!]!
    burnHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BurnHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BurnHistoryEntity_filter
    ): [BurnHistoryEntity!]!
    burnHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BurnHistoryEntity
    chamberActionResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ChamberActionResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ChamberActionResultEntity_filter
    ): [ChamberActionResultEntity!]!
    chamberActionResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ChamberActionResultEntity
    chamberEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ChamberEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ChamberEntity_filter
    ): [ChamberEntity!]!
    chamberEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ChamberEntity
    controllableEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ControllableEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ControllableEntity_filter
    ): [ControllableEntity!]!
    controllableEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ControllableEntity
    controllerEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ControllerEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ControllerEntity_filter
    ): [ControllerEntity!]!
    controllerEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ControllerEntity
    coreAttributesEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CoreAttributesEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CoreAttributesEntity_filter
    ): [CoreAttributesEntity!]!
    coreAttributesEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CoreAttributesEntity
    daustatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DAUStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DAUStatisticEntity_filter
    ): [DAUStatisticEntity!]!
    daustatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DAUStatisticEntity
    dungeonChamberMeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonChamberMeta
    dungeonChamberMetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonChamberMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonChamberMeta_filter
    ): [DungeonChamberMeta!]!
    dungeonEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonEntity_filter
    ): [DungeonEntity!]!
    dungeonEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonEntity
    dungeonFactoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonFactoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonFactoryEntity_filter
    ): [DungeonFactoryEntity!]!
    dungeonFactoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonFactoryEntity
    dungeonLogicEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonLogicEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonLogicEntity_filter
    ): [DungeonLogicEntity!]!
    dungeonLogicEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonLogicEntity
    dungeonRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonRequirements_filter
    ): [DungeonRequirements!]!
    dungeonRunCounterEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonRunCounterEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonRunCounterEntity_filter
    ): [DungeonRunCounterEntity!]!
    dungeonRunCounterEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonRunCounterEntity
    dungeonTreasuryTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonTreasuryTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonTreasuryTokenEntity_filter
    ): [DungeonTreasuryTokenEntity!]!
    dungeonTreasuryTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonTreasuryTokenEntity
    eventGenerateInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoData
    eventGenerateInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoData_filter
    ): [EventGenerateInfoData!]!
    eventGenerateInfoNegativeStatData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoNegativeStatData
    eventGenerateInfoNegativeStatDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoNegativeStatData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoNegativeStatData_filter
    ): [EventGenerateInfoNegativeStatData!]!
    eventGenerateInfoPositiveStatData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoPositiveStatData
    eventGenerateInfoPositiveStatDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoPositiveStatData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoPositiveStatData_filter
    ): [EventGenerateInfoPositiveStatData!]!
    eventResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventResultEntity_filter
    ): [EventResultEntity!]!
    eventResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventResultEntity
    fightResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FightResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FightResultEntity_filter
    ): [FightResultEntity!]!
    fightResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FightResultEntity
    fighterInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FighterInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FighterInfoEntity_filter
    ): [FighterInfoEntity!]!
    fighterInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FighterInfoEntity
    fighterTurnResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FighterTurnResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FighterTurnResultEntity_filter
    ): [FighterTurnResultEntity!]!
    fighterTurnResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FighterTurnResultEntity
    generalHeroTokenEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GeneralHeroTokenEarned
    generalHeroTokenEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GeneralHeroTokenEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GeneralHeroTokenEarned_filter
    ): [GeneralHeroTokenEarned!]!
    generalTokenomicsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GeneralTokenomicsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GeneralTokenomicsEntity_filter
    ): [GeneralTokenomicsEntity!]!
    generalTokenomicsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GeneralTokenomicsEntity
    globalCustomDataEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GlobalCustomDataEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GlobalCustomDataEntity_filter
    ): [GlobalCustomDataEntity!]!
    globalCustomDataEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GlobalCustomDataEntity
    heroAction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroAction
    heroActions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroAction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroAction_filter
    ): [HeroAction!]!
    heroCustomData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroCustomData
    heroCustomDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroCustomData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroCustomData_filter
    ): [HeroCustomData!]!
    heroEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroEntity_filter
    ): [HeroEntity!]!
    heroEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroEntity
    heroItemEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroItemEarned
    heroItemEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroItemEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroItemEarned_filter
    ): [HeroItemEarned!]!
    heroMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroMetaEntity_filter
    ): [HeroMetaEntity!]!
    heroMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroMetaEntity
    heroStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroStatEntity_filter
    ): [HeroStatEntity!]!
    heroStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroStatEntity
    heroTokenEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokenEarned
    heroTokenEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokenEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokenEarned_filter
    ): [HeroTokenEarned!]!
    heroTokensVaultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultEntity_filter
    ): [HeroTokensVaultEntity!]!
    heroTokensVaultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultEntity
    heroTokensVaultHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultHistoryEntity_filter
    ): [HeroTokensVaultHistoryEntity!]!
    heroTokensVaultHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultHistoryEntity
    heroTokensVaultStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultStatisticEntity_filter
    ): [HeroTokensVaultStatisticEntity!]!
    heroTokensVaultStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultStatisticEntity
    itemActionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemActionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemActionEntity_filter
    ): [ItemActionEntity!]!
    itemActionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemActionEntity
    itemBuffInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemBuffInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemBuffInfoEntity_filter
    ): [ItemBuffInfoEntity!]!
    itemBuffInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemBuffInfoEntity
    itemConsumableInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemConsumableInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemConsumableInfoEntity_filter
    ): [ItemConsumableInfoEntity!]!
    itemConsumableInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemConsumableInfoEntity
    itemEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemEntity_filter
    ): [ItemEntity!]!
    itemEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemEntity
    itemMagicAttackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMagicAttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMagicAttackInfoEntity_filter
    ): [ItemMagicAttackInfoEntity!]!
    itemMagicAttackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMagicAttackInfoEntity
    itemMetaConsumableInfoAttributeEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaConsumableInfoAttributeEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaConsumableInfoAttributeEntity_filter
    ): [ItemMetaConsumableInfoAttributeEntity!]!
    itemMetaConsumableInfoAttributeEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaConsumableInfoAttributeEntity
    itemMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaEntity_filter
    ): [ItemMetaEntity!]!
    itemMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaEntity
    itemMetaGeneralParamsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaGeneralParamsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaGeneralParamsEntity_filter
    ): [ItemMetaGeneralParamsEntity!]!
    itemMetaGeneralParamsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaGeneralParamsEntity
    itemMetaGenerateInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaGenerateInfo
    itemMetaGenerateInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaGenerateInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaGenerateInfo_filter
    ): [ItemMetaGenerateInfo!]!
    itemMetaMagicAttackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaMagicAttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaMagicAttackInfoEntity_filter
    ): [ItemMetaMagicAttackInfoEntity!]!
    itemMetaMagicAttackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaMagicAttackInfoEntity
    itemMetaParamsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaParamsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaParamsEntity_filter
    ): [ItemMetaParamsEntity!]!
    itemMetaParamsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaParamsEntity
    itemsBurntResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemsBurntResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemsBurntResultEntity_filter
    ): [ItemsBurntResultEntity!]!
    itemsBurntResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemsBurntResultEntity
    monsterGenerateAttackInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterGenerateAttackInfoData
    monsterGenerateAttackInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterGenerateAttackInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterGenerateAttackInfoData_filter
    ): [MonsterGenerateAttackInfoData!]!
    monsterGenerateInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterGenerateInfoData
    monsterGenerateInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterGenerateInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterGenerateInfoData_filter
    ): [MonsterGenerateInfoData!]!
    monsterInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterInfoEntity_filter
    ): [MonsterInfoEntity!]!
    monsterInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterInfoEntity
    monsterMintItemData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterMintItemData
    monsterMintItemDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterMintItemData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterMintItemData_filter
    ): [MonsterMintItemData!]!
    openedChamberEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OpenedChamberEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OpenedChamberEntity_filter
    ): [OpenedChamberEntity!]!
    openedChamberEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OpenedChamberEntity
    pawnshopEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopEntity_filter
    ): [PawnshopEntity!]!
    pawnshopEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopEntity
    pawnshopPositionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionEntity_filter
    ): [PawnshopPositionEntity!]!
    pawnshopPositionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionEntity
    pawnshopPositionHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionHistoryEntity_filter
    ): [PawnshopPositionHistoryEntity!]!
    pawnshopPositionHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionHistoryEntity
    pawnshopPositionItemStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionItemStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionItemStatEntity_filter
    ): [PawnshopPositionItemStatEntity!]!
    pawnshopPositionItemStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionItemStatEntity
    pawnshopStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopStatisticEntity_filter
    ): [PawnshopStatisticEntity!]!
    pawnshopStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopStatisticEntity
    pawnshopUserEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopUserEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopUserEntity_filter
    ): [PawnshopUserEntity!]!
    pawnshopUserEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopUserEntity
    registeredNameEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RegisteredNameEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RegisteredNameEntity_filter
    ): [RegisteredNameEntity!]!
    registeredNameEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegisteredNameEntity
    reinforcementRewardItemEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReinforcementRewardItemEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReinforcementRewardItemEntity_filter
    ): [ReinforcementRewardItemEntity!]!
    reinforcementRewardItemEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReinforcementRewardItemEntity
    reinforcementRewardTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReinforcementRewardTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReinforcementRewardTokenEntity_filter
    ): [ReinforcementRewardTokenEntity!]!
    reinforcementRewardTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReinforcementRewardTokenEntity
    statsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatsEntity_filter
    ): [StatsEntity!]!
    statsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatsEntity
    statsMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatsMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatsMetaEntity_filter
    ): [StatsMetaEntity!]!
    statsMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatsMetaEntity
    statusesEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatusesEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatusesEntity_filter
    ): [StatusesEntity!]!
    statusesEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatusesEntity
    storyEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryEntity_filter
    ): [StoryEntity!]!
    storyEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryEntity
    storyMetaAnswerAttributeRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerAttributeRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerAttributeRequirements_filter
    ): [StoryMetaAnswerAttributeRequirements!]!
    storyMetaAnswerDataRequirement(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaAnswerDataRequirement
    storyMetaAnswerDataRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerDataRequirement_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerDataRequirement_filter
    ): [StoryMetaAnswerDataRequirement!]!
    storyMetaAnswerItemRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerItemRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerItemRequirements_filter
    ): [StoryMetaAnswerItemRequirements!]!
    storyMetaAnswerNextPage(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaAnswerNextPage
    storyMetaAnswerNextPages(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerNextPage_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerNextPage_filter
    ): [StoryMetaAnswerNextPage!]!
    storyMetaAnswerTokenRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerTokenRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerTokenRequirements_filter
    ): [StoryMetaAnswerTokenRequirements!]!
    storyMetaAnswers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswers_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswers_filter
    ): [StoryMetaAnswers!]!
    storyMetaHeroCustomData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaHeroCustomData
    storyMetaHeroCustomDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaHeroCustomData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaHeroCustomData_filter
    ): [StoryMetaHeroCustomData!]!
    storyMetaInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaInfo
    storyMetaInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaInfo_filter
    ): [StoryMetaInfo!]!
    storyMetaObjectsRewrite(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaObjectsRewrite
    storyMetaObjectsRewrites(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaObjectsRewrite_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaObjectsRewrite_filter
    ): [StoryMetaObjectsRewrite!]!
    storyPageEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryPageEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryPageEntity_filter
    ): [StoryPageEntity!]!
    storyPageEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryPageEntity
    storyResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryResultEntity_filter
    ): [StoryResultEntity!]!
    storyResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryResultEntity
    tokenAmountEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAmountEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAmountEntity_filter
    ): [TokenAmountEntity!]!
    tokenAmountEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAmountEntity
    tokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenEntity_filter
    ): [TokenEntity!]!
    tokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenEntity
    tokenTransactionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTransactionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenTransactionEntity_filter
    ): [TokenTransactionEntity!]!
    tokenTransactionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenTransactionEntity
    totalSupplyHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TotalSupplyHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TotalSupplyHistoryEntity_filter
    ): [TotalSupplyHistoryEntity!]!
    totalSupplyHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TotalSupplyHistoryEntity
    totalTxStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TotalTxStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TotalTxStatisticEntity_filter
    ): [TotalTxStatisticEntity!]!
    totalTxStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TotalTxStatisticEntity
    treasuryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryEntity_filter
    ): [TreasuryEntity!]!
    treasuryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryEntity
    treasuryTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryTokenEntity_filter
    ): [TreasuryTokenEntity!]!
    treasuryTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryTokenEntity
    treasuryTokenInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryTokenInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryTokenInfoEntity_filter
    ): [TreasuryTokenInfoEntity!]!
    treasuryTokenInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryTokenInfoEntity
    userEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserEntity_filter
    ): [UserEntity!]!
    userEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserEntity
    userStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserStatEntity_filter
    ): [UserStatEntity!]!
    userStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserStatEntity
}

type RegisteredNameEntity {
    controller: ControllerEntity!
    id: ID!
}

type ReinforcementRewardItemEntity {
    hero: HeroEntity!
    id: ID!
    item: ItemEntity!
}

type ReinforcementRewardTokenEntity {
    hero: HeroEntity!
    id: ID!
    tokenInfo: TokenAmountEntity!
}

type StatsEntity {
    experience: Int!
    id: ID!
    level: Int!
    life: Int!
    lifeChances: Int!
    mana: Int!
}

type StatsMetaEntity {
    experience: BigInt
    id: ID!
    level: BigInt
    life: BigInt
    lifeChances: BigInt
    mana: BigInt
}

type StatusesEntity {
    burn: Boolean!
    confuse: Boolean!
    curse: Boolean!
    freeze: Boolean!
    gotCriticalHit: Boolean!
    hitBlocked: Boolean!
    id: ID!
    missed: Boolean!
    poison: Boolean!
    stun: Boolean!
}

type StoryEntity {
    answerAttributeRequirements: StoryMetaAnswerAttributeRequirements
    answerAttributes: AnswerAttributes
    answerBurnRandomItemMeta: AnswerBurnRandomItemMeta
    answerGlobalCustomDataRequirement: StoryMetaAnswerDataRequirement
    answerHeroCustomDataRequirement: StoryMetaAnswerDataRequirement
    answerItemRequirements: StoryMetaAnswerItemRequirements
    answerNextPage: StoryMetaAnswerNextPage
    answerTokenRequirements: StoryMetaAnswerTokenRequirements
    answersMeta: StoryMetaAnswers
    failGlobalCustomData: StoryMetaHeroCustomData
    failHeroCustomData: StoryMetaHeroCustomData
    failInfo: StoryMetaInfo
    id: ID!
    minLevel: BigInt
    nextObjRewriteMeta: StoryMetaObjectsRewrite
    requiredCustomDataIndex: [Bytes!]!
    requiredCustomDataIsHero: [Boolean!]!
    requiredCustomDataMaxValue: [BigInt!]!
    requiredCustomDataMinValue: [BigInt!]!
    storyId: String!
    successGlobalCustomData: StoryMetaHeroCustomData
    successHeroCustomData: StoryMetaHeroCustomData
    successInfo: StoryMetaInfo
}

type StoryMetaAnswerAttributeRequirements {
    answerId: [Int!]!
    cores: [String!]!
    heroClass: [Int!]!
    id: ID!
    ids: [String!]!
    pageId: [Int!]!
    values: [String!]!
}

type StoryMetaAnswerDataRequirement {
    answerId: [Int!]!
    dataIndexes: [String!]!
    dataValuesMax: [String!]!
    dataValuesMin: [String!]!
    heroClass: [Int!]!
    id: ID!
    mandatory: [String!]!
    pageId: [Int!]!
}

type StoryMetaAnswerItemRequirements {
    answerId: [Int!]!
    heroClass: [Int!]!
    id: ID!
    pageId: [Int!]!
    requireItemBurn: [String!]!
    requireItemEquipped: [String!]!
    requireItems: [String!]!
}

type StoryMetaAnswerNextPage {
    answerId: [Int!]!
    answerNextPageIds: [String!]!
    answerResultIds: [Int!]!
    heroClass: [Int!]!
    id: ID!
    pageId: [Int!]!
}

type StoryMetaAnswerTokenRequirements {
    answerId: [Int!]!
    heroClass: [Int!]!
    id: ID!
    pageId: [Int!]!
    requireAmount: [String!]!
    requireToken: [String!]!
    requireTransfer: [String!]!
}

type StoryMetaAnswers {
    answerHeroClasses: [Int!]!
    answerIds: [Int!]!
    answerPageIds: [Int!]!
    id: ID!
}

type StoryMetaHeroCustomData {
    answerId: [Int!]!
    dataIndexes: [String!]!
    dataValues: [String!]!
    heroClass: [Int!]!
    id: ID!
    pageId: [Int!]!
}

type StoryMetaInfo {
    answerId: [Int!]!
    attributeIds: [String!]!
    attributeValues: [String!]!
    damage: [Int!]!
    experience: [BigInt!]!
    heal: [Int!]!
    heroClass: [Int!]!
    id: ID!
    lifeChancesRecovered: [Int!]!
    manaConsumed: [Int!]!
    manaRegen: [Int!]!
    mintItems: [String!]!
    mintItemsChances: [String!]!
    pageId: [Int!]!
}

type StoryMetaObjectsRewrite {
    id: ID!
    nextObjHeroClasses: [Int!]!
    nextObjIds: [String!]!
    nextObjPageIds: [Int!]!
}

type StoryPageEntity {
    chamber: ChamberEntity!
    createdAtBlock: BigInt!
    heroAdr: String!
    heroId: Int!
    heroPage: Int!
    id: ID!
    openChamber: OpenedChamberEntity!
    storyId: Int!
    timestamp: BigInt!
}

type StoryResultEntity {
    attributes: [Int!]!
    dungeonId: Int!
    hero: String!
    heroId: BigDecimal!
    id: ID!
    iteration: Int!
    objectId: Int!
    result: ChamberActionResultEntity!
    salt: Int!
    stage: Int!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    answerAttributes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerAttributes_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerAttributes_filter
    ): [AnswerAttributes!]!
    answerBurnRandomItemMeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AnswerBurnRandomItemMeta
    answerBurnRandomItemMetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerBurnRandomItemMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerBurnRandomItemMeta_filter
    ): [AnswerBurnRandomItemMeta!]!
    attackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AttackInfoEntity_filter
    ): [AttackInfoEntity!]!
    attackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AttackInfoEntity
    attributeGenerateInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AttributeGenerateInfo
    attributeGenerateInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AttributeGenerateInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AttributeGenerateInfo_filter
    ): [AttributeGenerateInfo!]!
    burnHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BurnHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BurnHistoryEntity_filter
    ): [BurnHistoryEntity!]!
    burnHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BurnHistoryEntity
    chamberActionResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ChamberActionResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ChamberActionResultEntity_filter
    ): [ChamberActionResultEntity!]!
    chamberActionResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ChamberActionResultEntity
    chamberEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ChamberEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ChamberEntity_filter
    ): [ChamberEntity!]!
    chamberEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ChamberEntity
    controllableEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ControllableEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ControllableEntity_filter
    ): [ControllableEntity!]!
    controllableEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ControllableEntity
    controllerEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ControllerEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ControllerEntity_filter
    ): [ControllerEntity!]!
    controllerEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ControllerEntity
    coreAttributesEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CoreAttributesEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CoreAttributesEntity_filter
    ): [CoreAttributesEntity!]!
    coreAttributesEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CoreAttributesEntity
    daustatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DAUStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DAUStatisticEntity_filter
    ): [DAUStatisticEntity!]!
    daustatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DAUStatisticEntity
    dungeonChamberMeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonChamberMeta
    dungeonChamberMetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonChamberMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonChamberMeta_filter
    ): [DungeonChamberMeta!]!
    dungeonEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonEntity_filter
    ): [DungeonEntity!]!
    dungeonEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonEntity
    dungeonFactoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonFactoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonFactoryEntity_filter
    ): [DungeonFactoryEntity!]!
    dungeonFactoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonFactoryEntity
    dungeonLogicEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonLogicEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonLogicEntity_filter
    ): [DungeonLogicEntity!]!
    dungeonLogicEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonLogicEntity
    dungeonRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonRequirements_filter
    ): [DungeonRequirements!]!
    dungeonRunCounterEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonRunCounterEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonRunCounterEntity_filter
    ): [DungeonRunCounterEntity!]!
    dungeonRunCounterEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonRunCounterEntity
    dungeonTreasuryTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonTreasuryTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonTreasuryTokenEntity_filter
    ): [DungeonTreasuryTokenEntity!]!
    dungeonTreasuryTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonTreasuryTokenEntity
    eventGenerateInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoData
    eventGenerateInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoData_filter
    ): [EventGenerateInfoData!]!
    eventGenerateInfoNegativeStatData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoNegativeStatData
    eventGenerateInfoNegativeStatDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoNegativeStatData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoNegativeStatData_filter
    ): [EventGenerateInfoNegativeStatData!]!
    eventGenerateInfoPositiveStatData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventGenerateInfoPositiveStatData
    eventGenerateInfoPositiveStatDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventGenerateInfoPositiveStatData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventGenerateInfoPositiveStatData_filter
    ): [EventGenerateInfoPositiveStatData!]!
    eventResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: EventResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: EventResultEntity_filter
    ): [EventResultEntity!]!
    eventResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EventResultEntity
    fightResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FightResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FightResultEntity_filter
    ): [FightResultEntity!]!
    fightResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FightResultEntity
    fighterInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FighterInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FighterInfoEntity_filter
    ): [FighterInfoEntity!]!
    fighterInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FighterInfoEntity
    fighterTurnResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FighterTurnResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FighterTurnResultEntity_filter
    ): [FighterTurnResultEntity!]!
    fighterTurnResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FighterTurnResultEntity
    generalHeroTokenEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GeneralHeroTokenEarned
    generalHeroTokenEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GeneralHeroTokenEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GeneralHeroTokenEarned_filter
    ): [GeneralHeroTokenEarned!]!
    generalTokenomicsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GeneralTokenomicsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GeneralTokenomicsEntity_filter
    ): [GeneralTokenomicsEntity!]!
    generalTokenomicsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GeneralTokenomicsEntity
    globalCustomDataEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GlobalCustomDataEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GlobalCustomDataEntity_filter
    ): [GlobalCustomDataEntity!]!
    globalCustomDataEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GlobalCustomDataEntity
    heroAction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroAction
    heroActions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroAction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroAction_filter
    ): [HeroAction!]!
    heroCustomData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroCustomData
    heroCustomDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroCustomData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroCustomData_filter
    ): [HeroCustomData!]!
    heroEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroEntity_filter
    ): [HeroEntity!]!
    heroEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroEntity
    heroItemEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroItemEarned
    heroItemEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroItemEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroItemEarned_filter
    ): [HeroItemEarned!]!
    heroMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroMetaEntity_filter
    ): [HeroMetaEntity!]!
    heroMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroMetaEntity
    heroStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroStatEntity_filter
    ): [HeroStatEntity!]!
    heroStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroStatEntity
    heroTokenEarned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokenEarned
    heroTokenEarneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokenEarned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokenEarned_filter
    ): [HeroTokenEarned!]!
    heroTokensVaultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultEntity_filter
    ): [HeroTokensVaultEntity!]!
    heroTokensVaultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultEntity
    heroTokensVaultHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultHistoryEntity_filter
    ): [HeroTokensVaultHistoryEntity!]!
    heroTokensVaultHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultHistoryEntity
    heroTokensVaultStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HeroTokensVaultStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HeroTokensVaultStatisticEntity_filter
    ): [HeroTokensVaultStatisticEntity!]!
    heroTokensVaultStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HeroTokensVaultStatisticEntity
    itemActionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemActionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemActionEntity_filter
    ): [ItemActionEntity!]!
    itemActionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemActionEntity
    itemBuffInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemBuffInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemBuffInfoEntity_filter
    ): [ItemBuffInfoEntity!]!
    itemBuffInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemBuffInfoEntity
    itemConsumableInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemConsumableInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemConsumableInfoEntity_filter
    ): [ItemConsumableInfoEntity!]!
    itemConsumableInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemConsumableInfoEntity
    itemEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemEntity_filter
    ): [ItemEntity!]!
    itemEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemEntity
    itemMagicAttackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMagicAttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMagicAttackInfoEntity_filter
    ): [ItemMagicAttackInfoEntity!]!
    itemMagicAttackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMagicAttackInfoEntity
    itemMetaConsumableInfoAttributeEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaConsumableInfoAttributeEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaConsumableInfoAttributeEntity_filter
    ): [ItemMetaConsumableInfoAttributeEntity!]!
    itemMetaConsumableInfoAttributeEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaConsumableInfoAttributeEntity
    itemMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaEntity_filter
    ): [ItemMetaEntity!]!
    itemMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaEntity
    itemMetaGeneralParamsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaGeneralParamsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaGeneralParamsEntity_filter
    ): [ItemMetaGeneralParamsEntity!]!
    itemMetaGeneralParamsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaGeneralParamsEntity
    itemMetaGenerateInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaGenerateInfo
    itemMetaGenerateInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaGenerateInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaGenerateInfo_filter
    ): [ItemMetaGenerateInfo!]!
    itemMetaMagicAttackInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaMagicAttackInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaMagicAttackInfoEntity_filter
    ): [ItemMetaMagicAttackInfoEntity!]!
    itemMetaMagicAttackInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaMagicAttackInfoEntity
    itemMetaParamsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemMetaParamsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemMetaParamsEntity_filter
    ): [ItemMetaParamsEntity!]!
    itemMetaParamsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemMetaParamsEntity
    itemsBurntResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ItemsBurntResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ItemsBurntResultEntity_filter
    ): [ItemsBurntResultEntity!]!
    itemsBurntResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ItemsBurntResultEntity
    monsterGenerateAttackInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterGenerateAttackInfoData
    monsterGenerateAttackInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterGenerateAttackInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterGenerateAttackInfoData_filter
    ): [MonsterGenerateAttackInfoData!]!
    monsterGenerateInfoData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterGenerateInfoData
    monsterGenerateInfoDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterGenerateInfoData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterGenerateInfoData_filter
    ): [MonsterGenerateInfoData!]!
    monsterInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterInfoEntity_filter
    ): [MonsterInfoEntity!]!
    monsterInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterInfoEntity
    monsterMintItemData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MonsterMintItemData
    monsterMintItemDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MonsterMintItemData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MonsterMintItemData_filter
    ): [MonsterMintItemData!]!
    openedChamberEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OpenedChamberEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OpenedChamberEntity_filter
    ): [OpenedChamberEntity!]!
    openedChamberEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OpenedChamberEntity
    pawnshopEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopEntity_filter
    ): [PawnshopEntity!]!
    pawnshopEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopEntity
    pawnshopPositionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionEntity_filter
    ): [PawnshopPositionEntity!]!
    pawnshopPositionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionEntity
    pawnshopPositionHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionHistoryEntity_filter
    ): [PawnshopPositionHistoryEntity!]!
    pawnshopPositionHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionHistoryEntity
    pawnshopPositionItemStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopPositionItemStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopPositionItemStatEntity_filter
    ): [PawnshopPositionItemStatEntity!]!
    pawnshopPositionItemStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopPositionItemStatEntity
    pawnshopStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopStatisticEntity_filter
    ): [PawnshopStatisticEntity!]!
    pawnshopStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopStatisticEntity
    pawnshopUserEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PawnshopUserEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PawnshopUserEntity_filter
    ): [PawnshopUserEntity!]!
    pawnshopUserEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PawnshopUserEntity
    registeredNameEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RegisteredNameEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RegisteredNameEntity_filter
    ): [RegisteredNameEntity!]!
    registeredNameEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegisteredNameEntity
    reinforcementRewardItemEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReinforcementRewardItemEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReinforcementRewardItemEntity_filter
    ): [ReinforcementRewardItemEntity!]!
    reinforcementRewardItemEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReinforcementRewardItemEntity
    reinforcementRewardTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReinforcementRewardTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReinforcementRewardTokenEntity_filter
    ): [ReinforcementRewardTokenEntity!]!
    reinforcementRewardTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReinforcementRewardTokenEntity
    statsEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatsEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatsEntity_filter
    ): [StatsEntity!]!
    statsEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatsEntity
    statsMetaEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatsMetaEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatsMetaEntity_filter
    ): [StatsMetaEntity!]!
    statsMetaEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatsMetaEntity
    statusesEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StatusesEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StatusesEntity_filter
    ): [StatusesEntity!]!
    statusesEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StatusesEntity
    storyEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryEntity_filter
    ): [StoryEntity!]!
    storyEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryEntity
    storyMetaAnswerAttributeRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerAttributeRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerAttributeRequirements_filter
    ): [StoryMetaAnswerAttributeRequirements!]!
    storyMetaAnswerDataRequirement(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaAnswerDataRequirement
    storyMetaAnswerDataRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerDataRequirement_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerDataRequirement_filter
    ): [StoryMetaAnswerDataRequirement!]!
    storyMetaAnswerItemRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerItemRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerItemRequirements_filter
    ): [StoryMetaAnswerItemRequirements!]!
    storyMetaAnswerNextPage(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaAnswerNextPage
    storyMetaAnswerNextPages(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerNextPage_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerNextPage_filter
    ): [StoryMetaAnswerNextPage!]!
    storyMetaAnswerTokenRequirements(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswerTokenRequirements_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswerTokenRequirements_filter
    ): [StoryMetaAnswerTokenRequirements!]!
    storyMetaAnswers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaAnswers_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaAnswers_filter
    ): [StoryMetaAnswers!]!
    storyMetaHeroCustomData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaHeroCustomData
    storyMetaHeroCustomDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaHeroCustomData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaHeroCustomData_filter
    ): [StoryMetaHeroCustomData!]!
    storyMetaInfo(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaInfo
    storyMetaInfos(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaInfo_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaInfo_filter
    ): [StoryMetaInfo!]!
    storyMetaObjectsRewrite(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryMetaObjectsRewrite
    storyMetaObjectsRewrites(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryMetaObjectsRewrite_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryMetaObjectsRewrite_filter
    ): [StoryMetaObjectsRewrite!]!
    storyPageEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryPageEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryPageEntity_filter
    ): [StoryPageEntity!]!
    storyPageEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryPageEntity
    storyResultEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StoryResultEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StoryResultEntity_filter
    ): [StoryResultEntity!]!
    storyResultEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StoryResultEntity
    tokenAmountEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAmountEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAmountEntity_filter
    ): [TokenAmountEntity!]!
    tokenAmountEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAmountEntity
    tokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenEntity_filter
    ): [TokenEntity!]!
    tokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenEntity
    tokenTransactionEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTransactionEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenTransactionEntity_filter
    ): [TokenTransactionEntity!]!
    tokenTransactionEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenTransactionEntity
    totalSupplyHistoryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TotalSupplyHistoryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TotalSupplyHistoryEntity_filter
    ): [TotalSupplyHistoryEntity!]!
    totalSupplyHistoryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TotalSupplyHistoryEntity
    totalTxStatisticEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TotalTxStatisticEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TotalTxStatisticEntity_filter
    ): [TotalTxStatisticEntity!]!
    totalTxStatisticEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TotalTxStatisticEntity
    treasuryEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryEntity_filter
    ): [TreasuryEntity!]!
    treasuryEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryEntity
    treasuryTokenEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryTokenEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryTokenEntity_filter
    ): [TreasuryTokenEntity!]!
    treasuryTokenEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryTokenEntity
    treasuryTokenInfoEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TreasuryTokenInfoEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TreasuryTokenInfoEntity_filter
    ): [TreasuryTokenInfoEntity!]!
    treasuryTokenInfoEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TreasuryTokenInfoEntity
    userEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserEntity_filter
    ): [UserEntity!]!
    userEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserEntity
    userStatEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserStatEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserStatEntity_filter
    ): [UserStatEntity!]!
    userStatEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserStatEntity
}

type TokenAmountEntity {
    amount: BigDecimal!
    id: ID!
    token: TokenEntity!
}

type TokenEntity {
    decimals: Int!
    id: ID!
    name: String!
    symbol: String!
    totalSupply: BigInt!
}

type TokenTransactionEntity {
    amount: BigInt!
    createdAtBlock: BigInt!
    from: String!
    id: ID!
    price: BigDecimal!
    timestamp: BigInt!
    to: String!
    token: TokenEntity!
}

type TotalSupplyHistoryEntity {
    id: ID!
    timestamp: BigInt!
    token: TokenEntity!
    totalSupply: BigInt!
}

type TotalTxStatisticEntity {
    count: Int!
    id: ID!
}

type TreasuryEntity {
    id: ID!
    tokens(first: Int = 100, orderBy: TreasuryTokenEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TreasuryTokenEntity_filter): [TreasuryTokenEntity!]!
}

type TreasuryTokenEntity {
    id: ID!
    token: TokenAmountEntity!
    treasury: TreasuryEntity!
}

type TreasuryTokenInfoEntity {
    controller: ControllerEntity!
    customMinLevel: Int!
    id: ID!
    token: TokenEntity!
    valid: Boolean!
}

type UserEntity {
    heroes(first: Int = 100, orderBy: HeroEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HeroEntity_filter): [HeroEntity!]!
    id: ID!
    itemActions(first: Int = 100, orderBy: ItemActionEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemActionEntity_filter): [ItemActionEntity!]!
    items(first: Int = 100, orderBy: ItemEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemEntity_filter): [ItemEntity!]!
    lastActionBlock: Int!
    lastActionTs: Int!
    pawnshopActions(first: Int = 100, orderBy: PawnshopPositionHistoryEntity_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PawnshopPositionHistoryEntity_filter): [PawnshopPositionHistoryEntity!]!
    timestamp: BigInt!
    userStat: UserStatEntity!
}

type UserStatEntity {
    actions: Int!
    earned: BigInt!
    heroMaxLvl: Int!
    heroes: Int!
    id: ID!
    items: Int!
    pawnshopActions: Int!
    user: UserEntity!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum AnswerAttributes_orderBy {
    answerId
    delayRequirements
    heroClass
    id
    isFinalAnswer
    pageId
    randomRequirements
}

enum AnswerBurnRandomItemMeta_orderBy {
    answerId
    chances
    heroClass
    id
    isStopIfBurnt
    pageId
    slots
}

enum AttackInfoEntity_orderBy {
    attackToken
    attackToken__augmentationLevel
    attackToken__burned
    attackToken__durability
    attackToken__durabilityPercent
    attackToken__equipped
    attackToken__equippedSlot
    attackToken__id
    attackToken__itemId
    attackToken__rarity
    attackToken__score
    attackToken__uniqUri
    attackType
    id
    skillTokens
}

enum AttributeGenerateInfo_orderBy {
    id
    ids
    values
}

enum BurnHistoryEntity_orderBy {
    burn
    id
    timestamp
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
}

enum ChamberActionResultEntity_orderBy {
    chamber
    chamber__completed
    chamber__heroAdr
    chamber__heroId
    chamber__id
    chamber__iteration
    chamber__stage
    completed
    damage
    data
    experience
    fightResult
    heal
    id
    itemsBurnt
    kill
    lifeChancesRecovered
    manaConsumed
    manaRegen
    mintItems
    storyResult
    turn
}

enum ChamberEntity_orderBy {
    biome
    chamberName
    chamberSymbol
    chamberType
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    id
    isBattle
    isEvent
    isStory
    openedChambers
    uri
    valid
}

enum ControllableEntity_orderBy {
    controller
    createdBlock
    createdTs
    id
}

enum ControllerEntity_orderBy {
    controllable
    controllable__controller
    controllable__createdBlock
    controllable__createdTs
    controllable__id
    dungeonFactory
    fightDelay
    gameObjectController
    gameToken
    governance
    heroController
    heroes
    id
    itemController
    items
    oracle
    registeredNames
    reinforcementController
    statController
    storyController
    treasury
    treasuryTokenInfo
    treasury__id
}

enum CoreAttributesEntity_orderBy {
    dexterity
    energy
    id
    strength
    vitality
}

enum DAUStatisticEntity_orderBy {
    count
    id
    users
}

enum DungeonChamberMeta_orderBy {
    chamberChance
    chamberType
    dungeon
    dungeon__biome
    dungeon__id
    dungeon__maxLevel
    dungeon__minLevel
    dungeon__specificClass
    dungeon__specificLvl
    dungeon__stages
    dungeon__valid
    id
    uniqChamber
    uniqChamber__biome
    uniqChamber__chamberName
    uniqChamber__chamberSymbol
    uniqChamber__chamberType
    uniqChamber__id
    uniqChamber__isBattle
    uniqChamber__isEvent
    uniqChamber__isStory
    uniqChamber__uri
    uniqChamber__valid
}

enum DungeonEntity_orderBy {
    claimedItems
    claimedTokens
    currentChamber
    currentChamberIndex
    currentChamber__completed
    currentChamber__heroAdr
    currentChamber__heroId
    currentChamber__id
    currentChamber__iteration
    currentChamber__stage
    enteredHero
    enteredHero__biome
    enteredHero__burned
    enteredHero__dead
    enteredHero__heroId
    enteredHero__id
    enteredHero__lastFightTs
    enteredHero__lastTransfer
    enteredHero__maxBiomeCompleted
    enteredHero__nextLevelExperienceRequire
    enteredHero__previousLevelExperienceRequire
    enteredHero__refCode
    enteredHero__score
    enteredHero__staked
    enteredHero__stakedFee
    enteredHero__timestamp
    enteredHero__uniqName
    enteredHero__uniqUri
    factory
    factory__id
    id
    isCompleted
    logic
    logic__biome
    logic__id
    logic__maxLevel
    logic__minLevel
    logic__specificClass
    logic__specificLvl
    logic__stages
    logic__valid
    treasuryItems
    treasuryTokens
    valid
}

enum DungeonFactoryEntity_orderBy {
    controllable
    controllable__controller
    controllable__createdBlock
    controllable__createdTs
    controllable__id
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    dungeonLogics
    dungeons
    id
}

enum DungeonLogicEntity_orderBy {
    biome
    chambersMeta
    dungeons
    factory
    factory__id
    id
    maxLevel
    minLevel
    requirements
    specificClass
    specificLvl
    stages
    valid
}

enum DungeonRequirements_orderBy {
    dataIndex
    id
    isHeroData
    logic
    logic__biome
    logic__id
    logic__maxLevel
    logic__minLevel
    logic__specificClass
    logic__specificLvl
    logic__stages
    logic__valid
    maxValue
    minValue
}

enum DungeonRunCounterEntity_orderBy {
    count
    id
}

enum DungeonTreasuryTokenEntity_orderBy {
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    id
    token
    token__amount
    token__id
}

enum EventGenerateInfoData_orderBy {
    badAttributes
    badAttributes__id
    biome
    damage
    eventId
    experience
    goodAttributes
    goodAttributes__id
    goodChance
    heal
    id
    lifeChancesRecovered
    manaConsumed
    manaRegen
    mintItems
    mintItemsChances
    subType
}

enum EventGenerateInfoNegativeStatData_orderBy {
    damage
    id
    manaConsumed
}

enum EventGenerateInfoPositiveStatData_orderBy {
    experience
    heal
    id
    lifeChancesRecovered
    manaRegen
}

enum EventResultEntity_orderBy {
    damage
    experience
    heal
    id
    lifeChancesRecovered
    manaConsumed
    manaRegen
    negAttributes
    posAttributes
}

enum FightResultEntity_orderBy {
    fighterA
    fighterA__damage
    fighterA__damagePoison
    fighterA__damageReflect
    fighterA__health
    fighterA__id
    fighterA__manaConsumed
    fighterB
    fighterB__damage
    fighterB__damagePoison
    fighterB__damageReflect
    fighterB__health
    fighterB__id
    fighterB__manaConsumed
    id
    result
    result__completed
    result__damage
    result__data
    result__experience
    result__heal
    result__id
    result__kill
    result__lifeChancesRecovered
    result__manaConsumed
    result__manaRegen
    result__turn
}

enum FighterInfoEntity_orderBy {
    attackToken
    attackToken__augmentationLevel
    attackToken__burned
    attackToken__durability
    attackToken__durabilityPercent
    attackToken__equipped
    attackToken__equippedSlot
    attackToken__id
    attackToken__itemId
    attackToken__rarity
    attackToken__score
    attackToken__uniqUri
    attackType
    fighterAttributes
    fighterStats
    fighterStats__experience
    fighterStats__id
    fighterStats__level
    fighterStats__life
    fighterStats__lifeChances
    fighterStats__mana
    id
    race
}

enum FighterTurnResultEntity_orderBy {
    damage
    damagePoison
    damageReflect
    health
    id
    info
    info__attackType
    info__id
    info__race
    magicAttack
    magicAttack__attackType
    magicAttack__id
    magicAttack__maxDmg
    magicAttack__minDmg
    manaConsumed
    statuses
    statuses__burn
    statuses__confuse
    statuses__curse
    statuses__freeze
    statuses__gotCriticalHit
    statuses__hitBlocked
    statuses__id
    statuses__missed
    statuses__poison
    statuses__stun
}

enum GeneralHeroTokenEarned_orderBy {
    countAmount
    countReinforcementRewards
    id
    totalAmount
    totalReinforcementRewards
}

enum GeneralTokenomicsEntity_orderBy {
    heroes
    heroesByClass
    id
    liveHeroes
    liveHeroesByClass
    spentOnHero
    spentOnItems
    totalBurned
    totalMinted
    users
}

enum GlobalCustomDataEntity_orderBy {
    id
    value
}

enum HeroAction_orderBy {
    action
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    owner
    owner__id
    owner__lastActionBlock
    owner__lastActionTs
    owner__timestamp
    timestamp
    values
}

enum HeroCustomData_orderBy {
    dataIndex
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    value
}

enum HeroEntity_orderBy {
    actions
    attributes
    biome
    burned
    core
    core__dexterity
    core__energy
    core__id
    core__strength
    core__vitality
    customData
    dead
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    earnedItems
    earnedTokens
    heroId
    heroStat
    heroStat__battles
    heroStat__dungeonCompleted
    heroStat__events
    heroStat__id
    heroStat__itemsMinted
    heroStat__reinforcementTokenEarned
    heroStat__stories
    heroStat__tokenEarned
    id
    items
    lastFightTs
    lastTransfer
    maxBiomeCompleted
    meta
    meta__heroClass
    meta__id
    meta__name
    meta__symbol
    meta__uri
    meta__valid
    nextLevelExperienceRequire
    openedChambers
    owner
    owner__id
    owner__lastActionBlock
    owner__lastActionTs
    owner__timestamp
    previousLevelExperienceRequire
    refCode
    reinforcementHelper
    reinforcementHelper__biome
    reinforcementHelper__burned
    reinforcementHelper__dead
    reinforcementHelper__heroId
    reinforcementHelper__id
    reinforcementHelper__lastFightTs
    reinforcementHelper__lastTransfer
    reinforcementHelper__maxBiomeCompleted
    reinforcementHelper__nextLevelExperienceRequire
    reinforcementHelper__previousLevelExperienceRequire
    reinforcementHelper__refCode
    reinforcementHelper__score
    reinforcementHelper__staked
    reinforcementHelper__stakedFee
    reinforcementHelper__timestamp
    reinforcementHelper__uniqName
    reinforcementHelper__uniqUri
    reinforcementRewardItems
    reinforcementRewardTokens
    score
    staked
    stakedFee
    stats
    stats__experience
    stats__id
    stats__level
    stats__life
    stats__lifeChances
    stats__mana
    timestamp
    uniqName
    uniqUri
}

enum HeroItemEarned_orderBy {
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
    timestamp
}

enum HeroMetaEntity_orderBy {
    controllable
    controllable__controller
    controllable__createdBlock
    controllable__createdTs
    controllable__id
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    feeToken
    feeToken__amount
    feeToken__id
    heroClass
    id
    initialAttributes
    initialAttributes__dexterity
    initialAttributes__energy
    initialAttributes__id
    initialAttributes__strength
    initialAttributes__vitality
    name
    symbol
    uri
    valid
}

enum HeroStatEntity_orderBy {
    battles
    dungeonCompleted
    events
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    itemsMinted
    reinforcementTokenEarned
    stories
    tokenEarned
}

enum HeroTokenEarned_orderBy {
    amount
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    reinforcementStakedFee
    timestamp
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
}

enum HeroTokensVaultEntity_orderBy {
    createdAtBlock
    id
}

enum HeroTokensVaultHistoryEntity_orderBy {
    amount
    from
    from__id
    from__lastActionBlock
    from__lastActionTs
    from__timestamp
    id
    timestamp
    toBurn
    toGov
    toTreasury
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
}

enum HeroTokensVaultStatisticEntity_orderBy {
    amount
    id
    toBurn
    toGov
    toTreasury
}

enum ItemActionEntity_orderBy {
    action
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
    timestamp
    user
    user__id
    user__lastActionBlock
    user__lastActionTs
    user__timestamp
    values
}

enum ItemBuffInfoEntity_orderBy {
    casterAttributes
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
    manaConsumption
    targetAttributes
}

enum ItemConsumableInfoEntity_orderBy {
    attributes
    buffStats
    buffStats__experience
    buffStats__id
    buffStats__level
    buffStats__life
    buffStats__lifeChances
    buffStats__mana
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
}

enum ItemEntity_orderBy {
    actions
    attributes
    augmentationLevel
    buffInfo
    buffInfo__id
    buffInfo__manaConsumption
    burned
    consumableInfo
    consumableInfo__id
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    durability
    durabilityPercent
    equipped
    equippedSlot
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    itemId
    magicAttackInfo
    magicAttackInfo__attackType
    magicAttackInfo__id
    magicAttackInfo__maxDmg
    magicAttackInfo__minDmg
    meta
    meta__durability
    meta__id
    meta__isAttackItem
    meta__isBuffItem
    meta__isConsumableItem
    meta__itemType
    meta__level
    meta__manaCost
    meta__name
    meta__removed
    meta__symbol
    meta__uri
    meta__valid
    rarity
    score
    uniqUri
    user
    user__id
    user__lastActionBlock
    user__lastActionTs
    user__timestamp
}

enum ItemMagicAttackInfoEntity_orderBy {
    attackType
    attributesFactor
    attributesFactor__dexterity
    attributesFactor__energy
    attributesFactor__id
    attributesFactor__strength
    attributesFactor__vitality
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
    maxDmg
    minDmg
}

enum ItemMetaConsumableInfoAttributeEntity_orderBy {
    id
    ids
    values
}

enum ItemMetaEntity_orderBy {
    controllable
    controllable__controller
    controllable__createdBlock
    controllable__createdTs
    controllable__id
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    durability
    feeToken
    feeToken__amount
    feeToken__id
    id
    isAttackItem
    isBuffItem
    isConsumableItem
    itemType
    level
    manaCost
    name
    params
    params__augmentAmount
    params__augmentToken
    params__id
    pawnshopItemStat
    removed
    requirements
    requirements__dexterity
    requirements__energy
    requirements__id
    requirements__strength
    requirements__vitality
    symbol
    uri
    valid
}

enum ItemMetaGeneralParamsEntity_orderBy {
    baseDurability
    defaultRarity
    id
    itemLevel
    itemMetaType
    itemType
    manaCost
    maxRandomAttributes
    minRandomAttributes
    requirements
    requirements__dexterity
    requirements__energy
    requirements__id
    requirements__strength
    requirements__vitality
}

enum ItemMetaGenerateInfo_orderBy {
    chances
    id
    ids
    maxs
    mins
}

enum ItemMetaMagicAttackInfoEntity_orderBy {
    aType
    attributeFactors
    attributeFactors__dexterity
    attributeFactors__energy
    attributeFactors__id
    attributeFactors__strength
    attributeFactors__vitality
    id
    max
    min
}

enum ItemMetaParamsEntity_orderBy {
    augmentAmount
    augmentToken
    casterAttributes
    casterAttributes__id
    commonAttributes
    commonAttributes__id
    consumableAttributes
    consumableAttributes__id
    consumableStats
    consumableStats__experience
    consumableStats__id
    consumableStats__level
    consumableStats__life
    consumableStats__lifeChances
    consumableStats__mana
    genAttackInfo
    genAttackInfo__aType
    genAttackInfo__id
    genAttackInfo__max
    genAttackInfo__min
    id
    itemMeta
    itemMeta__baseDurability
    itemMeta__defaultRarity
    itemMeta__id
    itemMeta__itemLevel
    itemMeta__itemMetaType
    itemMeta__itemType
    itemMeta__manaCost
    itemMeta__maxRandomAttributes
    itemMeta__minRandomAttributes
    targetAttributes
    targetAttributes__id
}

enum ItemsBurntResultEntity_orderBy {
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
    result
    result__completed
    result__damage
    result__data
    result__experience
    result__heal
    result__id
    result__kill
    result__lifeChancesRecovered
    result__manaConsumed
    result__manaRegen
    result__turn
}

enum MonsterGenerateAttackInfoData_orderBy {
    attackToken
    attackTokenId
    attackType
    id
    mintItems
    mintItemsChances
}

enum MonsterGenerateInfoData_orderBy {
    attackInfo
    attackInfo__attackToken
    attackInfo__attackTokenId
    attackInfo__attackType
    attackInfo__id
    biome
    experience
    id
    ids
    level
    maxDropItems
    monsterId
    race
    subType
    values
}

enum MonsterInfoEntity_orderBy {
    attackInfo
    attackInfo__attackType
    attackInfo__id
    currentHp
    experience
    generated
    id
    level
    monsterAttributes
    race
    rarity
    turn
}

enum MonsterMintItemData_orderBy {
    id
    mintItems
    mintItemsChanges
}

enum OpenedChamberEntity_orderBy {
    actions
    chamber
    chamber__biome
    chamber__chamberName
    chamber__chamberSymbol
    chamber__chamberType
    chamber__id
    chamber__isBattle
    chamber__isEvent
    chamber__isStory
    chamber__uri
    chamber__valid
    completed
    dungeon
    dungeon__currentChamberIndex
    dungeon__id
    dungeon__isCompleted
    dungeon__valid
    enteredHero
    enteredHero__biome
    enteredHero__burned
    enteredHero__dead
    enteredHero__heroId
    enteredHero__id
    enteredHero__lastFightTs
    enteredHero__lastTransfer
    enteredHero__maxBiomeCompleted
    enteredHero__nextLevelExperienceRequire
    enteredHero__previousLevelExperienceRequire
    enteredHero__refCode
    enteredHero__score
    enteredHero__staked
    enteredHero__stakedFee
    enteredHero__timestamp
    enteredHero__uniqName
    enteredHero__uniqUri
    event
    event__damage
    event__experience
    event__heal
    event__id
    event__lifeChancesRecovered
    event__manaConsumed
    event__manaRegen
    heroAdr
    heroId
    id
    iteration
    monster
    monster__currentHp
    monster__experience
    monster__generated
    monster__id
    monster__level
    monster__race
    monster__rarity
    monster__turn
    pages
    stage
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum PawnshopEntity_orderBy {
    feeRecipient
    id
    owner
    platformFee
    positionDepositAmount
    positionDepositToken
    positionDepositToken__decimals
    positionDepositToken__id
    positionDepositToken__name
    positionDepositToken__symbol
    positionDepositToken__totalSupply
    positions
}

enum PawnshopPositionEntity_orderBy {
    acquiredAmount
    acquiredToken
    acquiredToken__decimals
    acquiredToken__id
    acquiredToken__name
    acquiredToken__symbol
    acquiredToken__totalSupply
    actions
    borrower
    borrower__id
    collateralAmount
    collateralHero
    collateralHero__biome
    collateralHero__burned
    collateralHero__dead
    collateralHero__heroId
    collateralHero__id
    collateralHero__lastFightTs
    collateralHero__lastTransfer
    collateralHero__maxBiomeCompleted
    collateralHero__nextLevelExperienceRequire
    collateralHero__previousLevelExperienceRequire
    collateralHero__refCode
    collateralHero__score
    collateralHero__staked
    collateralHero__stakedFee
    collateralHero__timestamp
    collateralHero__uniqName
    collateralHero__uniqUri
    collateralItem
    collateralItem__augmentationLevel
    collateralItem__burned
    collateralItem__durability
    collateralItem__durabilityPercent
    collateralItem__equipped
    collateralItem__equippedSlot
    collateralItem__id
    collateralItem__itemId
    collateralItem__rarity
    collateralItem__score
    collateralItem__uniqUri
    collateralNft
    collateralNftId
    collateralToken
    collateralToken__decimals
    collateralToken__id
    collateralToken__name
    collateralToken__symbol
    collateralToken__totalSupply
    createdBlock
    createdTs
    depositAmount
    depositToken
    depositToken__decimals
    depositToken__id
    depositToken__name
    depositToken__symbol
    depositToken__totalSupply
    executionLender
    executionLender__id
    executionPosEndBlock
    executionPosEndTs
    executionPosStartBlock
    executionPosStartTs
    id
    open
    pawnshop
    pawnshop__feeRecipient
    pawnshop__id
    pawnshop__owner
    pawnshop__platformFee
    pawnshop__positionDepositAmount
    posDurationBlocks
    posFee
    posId
}

enum PawnshopPositionHistoryEntity_orderBy {
    action
    id
    item
    item__durability
    item__id
    item__isAttackItem
    item__isBuffItem
    item__isConsumableItem
    item__itemType
    item__level
    item__manaCost
    item__name
    item__removed
    item__symbol
    item__uri
    item__valid
    position
    position__acquiredAmount
    position__collateralAmount
    position__collateralNft
    position__collateralNftId
    position__createdBlock
    position__createdTs
    position__depositAmount
    position__executionPosEndBlock
    position__executionPosEndTs
    position__executionPosStartBlock
    position__executionPosStartTs
    position__id
    position__open
    position__posDurationBlocks
    position__posFee
    position__posId
    timestamp
    user
    user__id
    user__lastActionBlock
    user__lastActionTs
    user__timestamp
    values
}

enum PawnshopPositionItemStatEntity_orderBy {
    avg
    id
    item
    item__durability
    item__id
    item__isAttackItem
    item__isBuffItem
    item__isConsumableItem
    item__itemType
    item__level
    item__manaCost
    item__name
    item__removed
    item__symbol
    item__uri
    item__valid
    max
    min
    prices
    totalTrades
}

enum PawnshopStatisticEntity_orderBy {
    avgClosePrice
    fees
    heroes
    id
    items
    maxClosePrice
    minClosePrice
    totalPosition
    volume
}

enum PawnshopUserEntity_orderBy {
    id
    openedPositions
}

enum RegisteredNameEntity_orderBy {
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    id
}

enum ReinforcementRewardItemEntity_orderBy {
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    item
    item__augmentationLevel
    item__burned
    item__durability
    item__durabilityPercent
    item__equipped
    item__equippedSlot
    item__id
    item__itemId
    item__rarity
    item__score
    item__uniqUri
}

enum ReinforcementRewardTokenEntity_orderBy {
    hero
    hero__biome
    hero__burned
    hero__dead
    hero__heroId
    hero__id
    hero__lastFightTs
    hero__lastTransfer
    hero__maxBiomeCompleted
    hero__nextLevelExperienceRequire
    hero__previousLevelExperienceRequire
    hero__refCode
    hero__score
    hero__staked
    hero__stakedFee
    hero__timestamp
    hero__uniqName
    hero__uniqUri
    id
    tokenInfo
    tokenInfo__amount
    tokenInfo__id
}

enum StatsEntity_orderBy {
    experience
    id
    level
    life
    lifeChances
    mana
}

enum StatsMetaEntity_orderBy {
    experience
    id
    level
    life
    lifeChances
    mana
}

enum StatusesEntity_orderBy {
    burn
    confuse
    curse
    freeze
    gotCriticalHit
    hitBlocked
    id
    missed
    poison
    stun
}

enum StoryEntity_orderBy {
    answerAttributeRequirements
    answerAttributeRequirements__id
    answerAttributes
    answerAttributes__id
    answerBurnRandomItemMeta
    answerBurnRandomItemMeta__id
    answerGlobalCustomDataRequirement
    answerGlobalCustomDataRequirement__id
    answerHeroCustomDataRequirement
    answerHeroCustomDataRequirement__id
    answerItemRequirements
    answerItemRequirements__id
    answerNextPage
    answerNextPage__id
    answerTokenRequirements
    answerTokenRequirements__id
    answersMeta
    answersMeta__id
    failGlobalCustomData
    failGlobalCustomData__id
    failHeroCustomData
    failHeroCustomData__id
    failInfo
    failInfo__id
    id
    minLevel
    nextObjRewriteMeta
    nextObjRewriteMeta__id
    requiredCustomDataIndex
    requiredCustomDataIsHero
    requiredCustomDataMaxValue
    requiredCustomDataMinValue
    storyId
    successGlobalCustomData
    successGlobalCustomData__id
    successHeroCustomData
    successHeroCustomData__id
    successInfo
    successInfo__id
}

enum StoryMetaAnswerAttributeRequirements_orderBy {
    answerId
    cores
    heroClass
    id
    ids
    pageId
    values
}

enum StoryMetaAnswerDataRequirement_orderBy {
    answerId
    dataIndexes
    dataValuesMax
    dataValuesMin
    heroClass
    id
    mandatory
    pageId
}

enum StoryMetaAnswerItemRequirements_orderBy {
    answerId
    heroClass
    id
    pageId
    requireItemBurn
    requireItemEquipped
    requireItems
}

enum StoryMetaAnswerNextPage_orderBy {
    answerId
    answerNextPageIds
    answerResultIds
    heroClass
    id
    pageId
}

enum StoryMetaAnswerTokenRequirements_orderBy {
    answerId
    heroClass
    id
    pageId
    requireAmount
    requireToken
    requireTransfer
}

enum StoryMetaAnswers_orderBy {
    answerHeroClasses
    answerIds
    answerPageIds
    id
}

enum StoryMetaHeroCustomData_orderBy {
    answerId
    dataIndexes
    dataValues
    heroClass
    id
    pageId
}

enum StoryMetaInfo_orderBy {
    answerId
    attributeIds
    attributeValues
    damage
    experience
    heal
    heroClass
    id
    lifeChancesRecovered
    manaConsumed
    manaRegen
    mintItems
    mintItemsChances
    pageId
}

enum StoryMetaObjectsRewrite_orderBy {
    id
    nextObjHeroClasses
    nextObjIds
    nextObjPageIds
}

enum StoryPageEntity_orderBy {
    chamber
    chamber__biome
    chamber__chamberName
    chamber__chamberSymbol
    chamber__chamberType
    chamber__id
    chamber__isBattle
    chamber__isEvent
    chamber__isStory
    chamber__uri
    chamber__valid
    createdAtBlock
    heroAdr
    heroId
    heroPage
    id
    openChamber
    openChamber__completed
    openChamber__heroAdr
    openChamber__heroId
    openChamber__id
    openChamber__iteration
    openChamber__stage
    storyId
    timestamp
}

enum StoryResultEntity_orderBy {
    attributes
    dungeonId
    hero
    heroId
    id
    iteration
    objectId
    result
    result__completed
    result__damage
    result__data
    result__experience
    result__heal
    result__id
    result__kill
    result__lifeChancesRecovered
    result__manaConsumed
    result__manaRegen
    result__turn
    salt
    stage
}

enum TokenAmountEntity_orderBy {
    amount
    id
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
}

enum TokenEntity_orderBy {
    decimals
    id
    name
    symbol
    totalSupply
}

enum TokenTransactionEntity_orderBy {
    amount
    createdAtBlock
    from
    id
    price
    timestamp
    to
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
}

enum TotalSupplyHistoryEntity_orderBy {
    id
    timestamp
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
    totalSupply
}

enum TotalTxStatisticEntity_orderBy {
    count
    id
}

enum TreasuryEntity_orderBy {
    id
    tokens
}

enum TreasuryTokenEntity_orderBy {
    id
    token
    token__amount
    token__id
    treasury
    treasury__id
}

enum TreasuryTokenInfoEntity_orderBy {
    controller
    controller__dungeonFactory
    controller__fightDelay
    controller__gameObjectController
    controller__gameToken
    controller__governance
    controller__heroController
    controller__id
    controller__itemController
    controller__oracle
    controller__reinforcementController
    controller__statController
    controller__storyController
    customMinLevel
    id
    token
    token__decimals
    token__id
    token__name
    token__symbol
    token__totalSupply
    valid
}

enum UserEntity_orderBy {
    heroes
    id
    itemActions
    items
    lastActionBlock
    lastActionTs
    pawnshopActions
    timestamp
    userStat
    userStat__actions
    userStat__earned
    userStat__heroMaxLvl
    userStat__heroes
    userStat__id
    userStat__items
    userStat__pawnshopActions
}

enum UserStatEntity_orderBy {
    actions
    earned
    heroMaxLvl
    heroes
    id
    items
    pawnshopActions
    user
    user__id
    user__lastActionBlock
    user__lastActionTs
    user__timestamp
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input AnswerAttributes_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [AnswerAttributes_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    delayRequirements: [BigInt!]
    delayRequirements_contains: [BigInt!]
    delayRequirements_contains_nocase: [BigInt!]
    delayRequirements_not: [BigInt!]
    delayRequirements_not_contains: [BigInt!]
    delayRequirements_not_contains_nocase: [BigInt!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isFinalAnswer: [Boolean!]
    isFinalAnswer_contains: [Boolean!]
    isFinalAnswer_contains_nocase: [Boolean!]
    isFinalAnswer_not: [Boolean!]
    isFinalAnswer_not_contains: [Boolean!]
    isFinalAnswer_not_contains_nocase: [Boolean!]
    or: [AnswerAttributes_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
    randomRequirements: [BigInt!]
    randomRequirements_contains: [BigInt!]
    randomRequirements_contains_nocase: [BigInt!]
    randomRequirements_not: [BigInt!]
    randomRequirements_not_contains: [BigInt!]
    randomRequirements_not_contains_nocase: [BigInt!]
}

input AnswerBurnRandomItemMeta_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [AnswerBurnRandomItemMeta_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    chances: [String!]
    chances_contains: [String!]
    chances_contains_nocase: [String!]
    chances_not: [String!]
    chances_not_contains: [String!]
    chances_not_contains_nocase: [String!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isStopIfBurnt: [String!]
    isStopIfBurnt_contains: [String!]
    isStopIfBurnt_contains_nocase: [String!]
    isStopIfBurnt_not: [String!]
    isStopIfBurnt_not_contains: [String!]
    isStopIfBurnt_not_contains_nocase: [String!]
    or: [AnswerBurnRandomItemMeta_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
    slots: [String!]
    slots_contains: [String!]
    slots_contains_nocase: [String!]
    slots_not: [String!]
    slots_not_contains: [String!]
    slots_not_contains_nocase: [String!]
}

input AttackInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [AttackInfoEntity_filter]
    attackToken: String
    attackToken_: ItemEntity_filter
    attackToken_contains: String
    attackToken_contains_nocase: String
    attackToken_ends_with: String
    attackToken_ends_with_nocase: String
    attackToken_gt: String
    attackToken_gte: String
    attackToken_in: [String!]
    attackToken_lt: String
    attackToken_lte: String
    attackToken_not: String
    attackToken_not_contains: String
    attackToken_not_contains_nocase: String
    attackToken_not_ends_with: String
    attackToken_not_ends_with_nocase: String
    attackToken_not_in: [String!]
    attackToken_not_starts_with: String
    attackToken_not_starts_with_nocase: String
    attackToken_starts_with: String
    attackToken_starts_with_nocase: String
    attackType: Int
    attackType_gt: Int
    attackType_gte: Int
    attackType_in: [Int!]
    attackType_lt: Int
    attackType_lte: Int
    attackType_not: Int
    attackType_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [AttackInfoEntity_filter]
    skillTokens: [String!]
    skillTokens_: ItemEntity_filter
    skillTokens_contains: [String!]
    skillTokens_contains_nocase: [String!]
    skillTokens_not: [String!]
    skillTokens_not_contains: [String!]
    skillTokens_not_contains_nocase: [String!]
}

input AttributeGenerateInfo_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [AttributeGenerateInfo_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ids: [Int!]
    ids_contains: [Int!]
    ids_contains_nocase: [Int!]
    ids_not: [Int!]
    ids_not_contains: [Int!]
    ids_not_contains_nocase: [Int!]
    or: [AttributeGenerateInfo_filter]
    values: [Int!]
    values_contains: [Int!]
    values_contains_nocase: [Int!]
    values_not: [Int!]
    values_not_contains: [Int!]
    values_not_contains_nocase: [Int!]
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input BurnHistoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [BurnHistoryEntity_filter]
    burn: BigInt
    burn_gt: BigInt
    burn_gte: BigInt
    burn_in: [BigInt!]
    burn_lt: BigInt
    burn_lte: BigInt
    burn_not: BigInt
    burn_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [BurnHistoryEntity_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input ChamberActionResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ChamberActionResultEntity_filter]
    chamber: String
    chamber_: OpenedChamberEntity_filter
    chamber_contains: String
    chamber_contains_nocase: String
    chamber_ends_with: String
    chamber_ends_with_nocase: String
    chamber_gt: String
    chamber_gte: String
    chamber_in: [String!]
    chamber_lt: String
    chamber_lte: String
    chamber_not: String
    chamber_not_contains: String
    chamber_not_contains_nocase: String
    chamber_not_ends_with: String
    chamber_not_ends_with_nocase: String
    chamber_not_in: [String!]
    chamber_not_starts_with: String
    chamber_not_starts_with_nocase: String
    chamber_starts_with: String
    chamber_starts_with_nocase: String
    completed: Boolean
    completed_in: [Boolean!]
    completed_not: Boolean
    completed_not_in: [Boolean!]
    damage: Int
    damage_gt: Int
    damage_gte: Int
    damage_in: [Int!]
    damage_lt: Int
    damage_lte: Int
    damage_not: Int
    damage_not_in: [Int!]
    data: String
    data_contains: String
    data_contains_nocase: String
    data_ends_with: String
    data_ends_with_nocase: String
    data_gt: String
    data_gte: String
    data_in: [String!]
    data_lt: String
    data_lte: String
    data_not: String
    data_not_contains: String
    data_not_contains_nocase: String
    data_not_ends_with: String
    data_not_ends_with_nocase: String
    data_not_in: [String!]
    data_not_starts_with: String
    data_not_starts_with_nocase: String
    data_starts_with: String
    data_starts_with_nocase: String
    experience: Int
    experience_gt: Int
    experience_gte: Int
    experience_in: [Int!]
    experience_lt: Int
    experience_lte: Int
    experience_not: Int
    experience_not_in: [Int!]
    fightResult_: FightResultEntity_filter
    heal: Int
    heal_gt: Int
    heal_gte: Int
    heal_in: [Int!]
    heal_lt: Int
    heal_lte: Int
    heal_not: Int
    heal_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemsBurnt_: ItemsBurntResultEntity_filter
    kill: Boolean
    kill_in: [Boolean!]
    kill_not: Boolean
    kill_not_in: [Boolean!]
    lifeChancesRecovered: Int
    lifeChancesRecovered_gt: Int
    lifeChancesRecovered_gte: Int
    lifeChancesRecovered_in: [Int!]
    lifeChancesRecovered_lt: Int
    lifeChancesRecovered_lte: Int
    lifeChancesRecovered_not: Int
    lifeChancesRecovered_not_in: [Int!]
    manaConsumed: Int
    manaConsumed_gt: Int
    manaConsumed_gte: Int
    manaConsumed_in: [Int!]
    manaConsumed_lt: Int
    manaConsumed_lte: Int
    manaConsumed_not: Int
    manaConsumed_not_in: [Int!]
    manaRegen: Int
    manaRegen_gt: Int
    manaRegen_gte: Int
    manaRegen_in: [Int!]
    manaRegen_lt: Int
    manaRegen_lte: Int
    manaRegen_not: Int
    manaRegen_not_in: [Int!]
    mintItems: [String!]
    mintItems_: ItemEntity_filter
    mintItems_contains: [String!]
    mintItems_contains_nocase: [String!]
    mintItems_not: [String!]
    mintItems_not_contains: [String!]
    mintItems_not_contains_nocase: [String!]
    or: [ChamberActionResultEntity_filter]
    storyResult_: StoryResultEntity_filter
    turn: Int
    turn_gt: Int
    turn_gte: Int
    turn_in: [Int!]
    turn_lt: Int
    turn_lte: Int
    turn_not: Int
    turn_not_in: [Int!]
}

input ChamberEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ChamberEntity_filter]
    biome: Int
    biome_gt: Int
    biome_gte: Int
    biome_in: [Int!]
    biome_lt: Int
    biome_lte: Int
    biome_not: Int
    biome_not_in: [Int!]
    chamberName: String
    chamberName_contains: String
    chamberName_contains_nocase: String
    chamberName_ends_with: String
    chamberName_ends_with_nocase: String
    chamberName_gt: String
    chamberName_gte: String
    chamberName_in: [String!]
    chamberName_lt: String
    chamberName_lte: String
    chamberName_not: String
    chamberName_not_contains: String
    chamberName_not_contains_nocase: String
    chamberName_not_ends_with: String
    chamberName_not_ends_with_nocase: String
    chamberName_not_in: [String!]
    chamberName_not_starts_with: String
    chamberName_not_starts_with_nocase: String
    chamberName_starts_with: String
    chamberName_starts_with_nocase: String
    chamberSymbol: String
    chamberSymbol_contains: String
    chamberSymbol_contains_nocase: String
    chamberSymbol_ends_with: String
    chamberSymbol_ends_with_nocase: String
    chamberSymbol_gt: String
    chamberSymbol_gte: String
    chamberSymbol_in: [String!]
    chamberSymbol_lt: String
    chamberSymbol_lte: String
    chamberSymbol_not: String
    chamberSymbol_not_contains: String
    chamberSymbol_not_contains_nocase: String
    chamberSymbol_not_ends_with: String
    chamberSymbol_not_ends_with_nocase: String
    chamberSymbol_not_in: [String!]
    chamberSymbol_not_starts_with: String
    chamberSymbol_not_starts_with_nocase: String
    chamberSymbol_starts_with: String
    chamberSymbol_starts_with_nocase: String
    chamberType: Int
    chamberType_gt: Int
    chamberType_gte: Int
    chamberType_in: [Int!]
    chamberType_lt: Int
    chamberType_lte: Int
    chamberType_not: Int
    chamberType_not_in: [Int!]
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isBattle: Boolean
    isBattle_in: [Boolean!]
    isBattle_not: Boolean
    isBattle_not_in: [Boolean!]
    isEvent: Boolean
    isEvent_in: [Boolean!]
    isEvent_not: Boolean
    isEvent_not_in: [Boolean!]
    isStory: Boolean
    isStory_in: [Boolean!]
    isStory_not: Boolean
    isStory_not_in: [Boolean!]
    openedChambers_: OpenedChamberEntity_filter
    or: [ChamberEntity_filter]
    uri: String
    uri_contains: String
    uri_contains_nocase: String
    uri_ends_with: String
    uri_ends_with_nocase: String
    uri_gt: String
    uri_gte: String
    uri_in: [String!]
    uri_lt: String
    uri_lte: String
    uri_not: String
    uri_not_contains: String
    uri_not_contains_nocase: String
    uri_not_ends_with: String
    uri_not_ends_with_nocase: String
    uri_not_in: [String!]
    uri_not_starts_with: String
    uri_not_starts_with_nocase: String
    uri_starts_with: String
    uri_starts_with_nocase: String
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input ControllableEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ControllableEntity_filter]
    controller: String
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    createdBlock: Int
    createdBlock_gt: Int
    createdBlock_gte: Int
    createdBlock_in: [Int!]
    createdBlock_lt: Int
    createdBlock_lte: Int
    createdBlock_not: Int
    createdBlock_not_in: [Int!]
    createdTs: Int
    createdTs_gt: Int
    createdTs_gte: Int
    createdTs_in: [Int!]
    createdTs_lt: Int
    createdTs_lte: Int
    createdTs_not: Int
    createdTs_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [ControllableEntity_filter]
}

input ControllerEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ControllerEntity_filter]
    controllable: String
    controllable_: ControllableEntity_filter
    controllable_contains: String
    controllable_contains_nocase: String
    controllable_ends_with: String
    controllable_ends_with_nocase: String
    controllable_gt: String
    controllable_gte: String
    controllable_in: [String!]
    controllable_lt: String
    controllable_lte: String
    controllable_not: String
    controllable_not_contains: String
    controllable_not_contains_nocase: String
    controllable_not_ends_with: String
    controllable_not_ends_with_nocase: String
    controllable_not_in: [String!]
    controllable_not_starts_with: String
    controllable_not_starts_with_nocase: String
    controllable_starts_with: String
    controllable_starts_with_nocase: String
    dungeonFactory: String
    dungeonFactory_contains: String
    dungeonFactory_contains_nocase: String
    dungeonFactory_ends_with: String
    dungeonFactory_ends_with_nocase: String
    dungeonFactory_gt: String
    dungeonFactory_gte: String
    dungeonFactory_in: [String!]
    dungeonFactory_lt: String
    dungeonFactory_lte: String
    dungeonFactory_not: String
    dungeonFactory_not_contains: String
    dungeonFactory_not_contains_nocase: String
    dungeonFactory_not_ends_with: String
    dungeonFactory_not_ends_with_nocase: String
    dungeonFactory_not_in: [String!]
    dungeonFactory_not_starts_with: String
    dungeonFactory_not_starts_with_nocase: String
    dungeonFactory_starts_with: String
    dungeonFactory_starts_with_nocase: String
    fightDelay: Int
    fightDelay_gt: Int
    fightDelay_gte: Int
    fightDelay_in: [Int!]
    fightDelay_lt: Int
    fightDelay_lte: Int
    fightDelay_not: Int
    fightDelay_not_in: [Int!]
    gameObjectController: String
    gameObjectController_contains: String
    gameObjectController_contains_nocase: String
    gameObjectController_ends_with: String
    gameObjectController_ends_with_nocase: String
    gameObjectController_gt: String
    gameObjectController_gte: String
    gameObjectController_in: [String!]
    gameObjectController_lt: String
    gameObjectController_lte: String
    gameObjectController_not: String
    gameObjectController_not_contains: String
    gameObjectController_not_contains_nocase: String
    gameObjectController_not_ends_with: String
    gameObjectController_not_ends_with_nocase: String
    gameObjectController_not_in: [String!]
    gameObjectController_not_starts_with: String
    gameObjectController_not_starts_with_nocase: String
    gameObjectController_starts_with: String
    gameObjectController_starts_with_nocase: String
    gameToken: String
    gameToken_contains: String
    gameToken_contains_nocase: String
    gameToken_ends_with: String
    gameToken_ends_with_nocase: String
    gameToken_gt: String
    gameToken_gte: String
    gameToken_in: [String!]
    gameToken_lt: String
    gameToken_lte: String
    gameToken_not: String
    gameToken_not_contains: String
    gameToken_not_contains_nocase: String
    gameToken_not_ends_with: String
    gameToken_not_ends_with_nocase: String
    gameToken_not_in: [String!]
    gameToken_not_starts_with: String
    gameToken_not_starts_with_nocase: String
    gameToken_starts_with: String
    gameToken_starts_with_nocase: String
    governance: String
    governance_contains: String
    governance_contains_nocase: String
    governance_ends_with: String
    governance_ends_with_nocase: String
    governance_gt: String
    governance_gte: String
    governance_in: [String!]
    governance_lt: String
    governance_lte: String
    governance_not: String
    governance_not_contains: String
    governance_not_contains_nocase: String
    governance_not_ends_with: String
    governance_not_ends_with_nocase: String
    governance_not_in: [String!]
    governance_not_starts_with: String
    governance_not_starts_with_nocase: String
    governance_starts_with: String
    governance_starts_with_nocase: String
    heroController: String
    heroController_contains: String
    heroController_contains_nocase: String
    heroController_ends_with: String
    heroController_ends_with_nocase: String
    heroController_gt: String
    heroController_gte: String
    heroController_in: [String!]
    heroController_lt: String
    heroController_lte: String
    heroController_not: String
    heroController_not_contains: String
    heroController_not_contains_nocase: String
    heroController_not_ends_with: String
    heroController_not_ends_with_nocase: String
    heroController_not_in: [String!]
    heroController_not_starts_with: String
    heroController_not_starts_with_nocase: String
    heroController_starts_with: String
    heroController_starts_with_nocase: String
    heroes_: HeroMetaEntity_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemController: String
    itemController_contains: String
    itemController_contains_nocase: String
    itemController_ends_with: String
    itemController_ends_with_nocase: String
    itemController_gt: String
    itemController_gte: String
    itemController_in: [String!]
    itemController_lt: String
    itemController_lte: String
    itemController_not: String
    itemController_not_contains: String
    itemController_not_contains_nocase: String
    itemController_not_ends_with: String
    itemController_not_ends_with_nocase: String
    itemController_not_in: [String!]
    itemController_not_starts_with: String
    itemController_not_starts_with_nocase: String
    itemController_starts_with: String
    itemController_starts_with_nocase: String
    items_: ItemMetaEntity_filter
    or: [ControllerEntity_filter]
    oracle: String
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    registeredNames_: RegisteredNameEntity_filter
    reinforcementController: String
    reinforcementController_contains: String
    reinforcementController_contains_nocase: String
    reinforcementController_ends_with: String
    reinforcementController_ends_with_nocase: String
    reinforcementController_gt: String
    reinforcementController_gte: String
    reinforcementController_in: [String!]
    reinforcementController_lt: String
    reinforcementController_lte: String
    reinforcementController_not: String
    reinforcementController_not_contains: String
    reinforcementController_not_contains_nocase: String
    reinforcementController_not_ends_with: String
    reinforcementController_not_ends_with_nocase: String
    reinforcementController_not_in: [String!]
    reinforcementController_not_starts_with: String
    reinforcementController_not_starts_with_nocase: String
    reinforcementController_starts_with: String
    reinforcementController_starts_with_nocase: String
    statController: String
    statController_contains: String
    statController_contains_nocase: String
    statController_ends_with: String
    statController_ends_with_nocase: String
    statController_gt: String
    statController_gte: String
    statController_in: [String!]
    statController_lt: String
    statController_lte: String
    statController_not: String
    statController_not_contains: String
    statController_not_contains_nocase: String
    statController_not_ends_with: String
    statController_not_ends_with_nocase: String
    statController_not_in: [String!]
    statController_not_starts_with: String
    statController_not_starts_with_nocase: String
    statController_starts_with: String
    statController_starts_with_nocase: String
    storyController: String
    storyController_contains: String
    storyController_contains_nocase: String
    storyController_ends_with: String
    storyController_ends_with_nocase: String
    storyController_gt: String
    storyController_gte: String
    storyController_in: [String!]
    storyController_lt: String
    storyController_lte: String
    storyController_not: String
    storyController_not_contains: String
    storyController_not_contains_nocase: String
    storyController_not_ends_with: String
    storyController_not_ends_with_nocase: String
    storyController_not_in: [String!]
    storyController_not_starts_with: String
    storyController_not_starts_with_nocase: String
    storyController_starts_with: String
    storyController_starts_with_nocase: String
    treasury: String
    treasuryTokenInfo_: TreasuryTokenInfoEntity_filter
    treasury_: TreasuryEntity_filter
    treasury_contains: String
    treasury_contains_nocase: String
    treasury_ends_with: String
    treasury_ends_with_nocase: String
    treasury_gt: String
    treasury_gte: String
    treasury_in: [String!]
    treasury_lt: String
    treasury_lte: String
    treasury_not: String
    treasury_not_contains: String
    treasury_not_contains_nocase: String
    treasury_not_ends_with: String
    treasury_not_ends_with_nocase: String
    treasury_not_in: [String!]
    treasury_not_starts_with: String
    treasury_not_starts_with_nocase: String
    treasury_starts_with: String
    treasury_starts_with_nocase: String
}

input CoreAttributesEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [CoreAttributesEntity_filter]
    dexterity: Int
    dexterity_gt: Int
    dexterity_gte: Int
    dexterity_in: [Int!]
    dexterity_lt: Int
    dexterity_lte: Int
    dexterity_not: Int
    dexterity_not_in: [Int!]
    energy: Int
    energy_gt: Int
    energy_gte: Int
    energy_in: [Int!]
    energy_lt: Int
    energy_lte: Int
    energy_not: Int
    energy_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [CoreAttributesEntity_filter]
    strength: Int
    strength_gt: Int
    strength_gte: Int
    strength_in: [Int!]
    strength_lt: Int
    strength_lte: Int
    strength_not: Int
    strength_not_in: [Int!]
    vitality: Int
    vitality_gt: Int
    vitality_gte: Int
    vitality_in: [Int!]
    vitality_lt: Int
    vitality_lte: Int
    vitality_not: Int
    vitality_not_in: [Int!]
}

input DAUStatisticEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DAUStatisticEntity_filter]
    count: Int
    count_gt: Int
    count_gte: Int
    count_in: [Int!]
    count_lt: Int
    count_lte: Int
    count_not: Int
    count_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [DAUStatisticEntity_filter]
    users: [String!]
    users_: UserEntity_filter
    users_contains: [String!]
    users_contains_nocase: [String!]
    users_not: [String!]
    users_not_contains: [String!]
    users_not_contains_nocase: [String!]
}

input DungeonChamberMeta_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonChamberMeta_filter]
    chamberChance: BigDecimal
    chamberChance_gt: BigDecimal
    chamberChance_gte: BigDecimal
    chamberChance_in: [BigDecimal!]
    chamberChance_lt: BigDecimal
    chamberChance_lte: BigDecimal
    chamberChance_not: BigDecimal
    chamberChance_not_in: [BigDecimal!]
    chamberType: Int
    chamberType_gt: Int
    chamberType_gte: Int
    chamberType_in: [Int!]
    chamberType_lt: Int
    chamberType_lte: Int
    chamberType_not: Int
    chamberType_not_in: [Int!]
    dungeon: String
    dungeon_: DungeonLogicEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [DungeonChamberMeta_filter]
    uniqChamber: String
    uniqChamber_: ChamberEntity_filter
    uniqChamber_contains: String
    uniqChamber_contains_nocase: String
    uniqChamber_ends_with: String
    uniqChamber_ends_with_nocase: String
    uniqChamber_gt: String
    uniqChamber_gte: String
    uniqChamber_in: [String!]
    uniqChamber_lt: String
    uniqChamber_lte: String
    uniqChamber_not: String
    uniqChamber_not_contains: String
    uniqChamber_not_contains_nocase: String
    uniqChamber_not_ends_with: String
    uniqChamber_not_ends_with_nocase: String
    uniqChamber_not_in: [String!]
    uniqChamber_not_starts_with: String
    uniqChamber_not_starts_with_nocase: String
    uniqChamber_starts_with: String
    uniqChamber_starts_with_nocase: String
}

input DungeonEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonEntity_filter]
    claimedItems_: HeroItemEarned_filter
    claimedTokens_: HeroTokenEarned_filter
    currentChamber: String
    currentChamberIndex: Int
    currentChamberIndex_gt: Int
    currentChamberIndex_gte: Int
    currentChamberIndex_in: [Int!]
    currentChamberIndex_lt: Int
    currentChamberIndex_lte: Int
    currentChamberIndex_not: Int
    currentChamberIndex_not_in: [Int!]
    currentChamber_: OpenedChamberEntity_filter
    currentChamber_contains: String
    currentChamber_contains_nocase: String
    currentChamber_ends_with: String
    currentChamber_ends_with_nocase: String
    currentChamber_gt: String
    currentChamber_gte: String
    currentChamber_in: [String!]
    currentChamber_lt: String
    currentChamber_lte: String
    currentChamber_not: String
    currentChamber_not_contains: String
    currentChamber_not_contains_nocase: String
    currentChamber_not_ends_with: String
    currentChamber_not_ends_with_nocase: String
    currentChamber_not_in: [String!]
    currentChamber_not_starts_with: String
    currentChamber_not_starts_with_nocase: String
    currentChamber_starts_with: String
    currentChamber_starts_with_nocase: String
    enteredHero: String
    enteredHero_: HeroEntity_filter
    enteredHero_contains: String
    enteredHero_contains_nocase: String
    enteredHero_ends_with: String
    enteredHero_ends_with_nocase: String
    enteredHero_gt: String
    enteredHero_gte: String
    enteredHero_in: [String!]
    enteredHero_lt: String
    enteredHero_lte: String
    enteredHero_not: String
    enteredHero_not_contains: String
    enteredHero_not_contains_nocase: String
    enteredHero_not_ends_with: String
    enteredHero_not_ends_with_nocase: String
    enteredHero_not_in: [String!]
    enteredHero_not_starts_with: String
    enteredHero_not_starts_with_nocase: String
    enteredHero_starts_with: String
    enteredHero_starts_with_nocase: String
    factory: String
    factory_: DungeonFactoryEntity_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isCompleted: Boolean
    isCompleted_in: [Boolean!]
    isCompleted_not: Boolean
    isCompleted_not_in: [Boolean!]
    logic: String
    logic_: DungeonLogicEntity_filter
    logic_contains: String
    logic_contains_nocase: String
    logic_ends_with: String
    logic_ends_with_nocase: String
    logic_gt: String
    logic_gte: String
    logic_in: [String!]
    logic_lt: String
    logic_lte: String
    logic_not: String
    logic_not_contains: String
    logic_not_contains_nocase: String
    logic_not_ends_with: String
    logic_not_ends_with_nocase: String
    logic_not_in: [String!]
    logic_not_starts_with: String
    logic_not_starts_with_nocase: String
    logic_starts_with: String
    logic_starts_with_nocase: String
    or: [DungeonEntity_filter]
    treasuryItems_: ItemEntity_filter
    treasuryTokens_: DungeonTreasuryTokenEntity_filter
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input DungeonFactoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonFactoryEntity_filter]
    controllable: String
    controllable_: ControllableEntity_filter
    controllable_contains: String
    controllable_contains_nocase: String
    controllable_ends_with: String
    controllable_ends_with_nocase: String
    controllable_gt: String
    controllable_gte: String
    controllable_in: [String!]
    controllable_lt: String
    controllable_lte: String
    controllable_not: String
    controllable_not_contains: String
    controllable_not_contains_nocase: String
    controllable_not_ends_with: String
    controllable_not_ends_with_nocase: String
    controllable_not_in: [String!]
    controllable_not_starts_with: String
    controllable_not_starts_with_nocase: String
    controllable_starts_with: String
    controllable_starts_with_nocase: String
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    dungeonLogics_: DungeonLogicEntity_filter
    dungeons_: DungeonEntity_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [DungeonFactoryEntity_filter]
}

input DungeonLogicEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonLogicEntity_filter]
    biome: Int
    biome_gt: Int
    biome_gte: Int
    biome_in: [Int!]
    biome_lt: Int
    biome_lte: Int
    biome_not: Int
    biome_not_in: [Int!]
    chambersMeta_: DungeonChamberMeta_filter
    dungeons_: DungeonEntity_filter
    factory: String
    factory_: DungeonFactoryEntity_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    maxLevel: Int
    maxLevel_gt: Int
    maxLevel_gte: Int
    maxLevel_in: [Int!]
    maxLevel_lt: Int
    maxLevel_lte: Int
    maxLevel_not: Int
    maxLevel_not_in: [Int!]
    minLevel: Int
    minLevel_gt: Int
    minLevel_gte: Int
    minLevel_in: [Int!]
    minLevel_lt: Int
    minLevel_lte: Int
    minLevel_not: Int
    minLevel_not_in: [Int!]
    or: [DungeonLogicEntity_filter]
    requirements_: DungeonRequirements_filter
    specificClass: Int
    specificClass_gt: Int
    specificClass_gte: Int
    specificClass_in: [Int!]
    specificClass_lt: Int
    specificClass_lte: Int
    specificClass_not: Int
    specificClass_not_in: [Int!]
    specificLvl: Int
    specificLvl_gt: Int
    specificLvl_gte: Int
    specificLvl_in: [Int!]
    specificLvl_lt: Int
    specificLvl_lte: Int
    specificLvl_not: Int
    specificLvl_not_in: [Int!]
    stages: Int
    stages_gt: Int
    stages_gte: Int
    stages_in: [Int!]
    stages_lt: Int
    stages_lte: Int
    stages_not: Int
    stages_not_in: [Int!]
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input DungeonRequirements_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonRequirements_filter]
    dataIndex: String
    dataIndex_contains: String
    dataIndex_contains_nocase: String
    dataIndex_ends_with: String
    dataIndex_ends_with_nocase: String
    dataIndex_gt: String
    dataIndex_gte: String
    dataIndex_in: [String!]
    dataIndex_lt: String
    dataIndex_lte: String
    dataIndex_not: String
    dataIndex_not_contains: String
    dataIndex_not_contains_nocase: String
    dataIndex_not_ends_with: String
    dataIndex_not_ends_with_nocase: String
    dataIndex_not_in: [String!]
    dataIndex_not_starts_with: String
    dataIndex_not_starts_with_nocase: String
    dataIndex_starts_with: String
    dataIndex_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isHeroData: Boolean
    isHeroData_in: [Boolean!]
    isHeroData_not: Boolean
    isHeroData_not_in: [Boolean!]
    logic: String
    logic_: DungeonLogicEntity_filter
    logic_contains: String
    logic_contains_nocase: String
    logic_ends_with: String
    logic_ends_with_nocase: String
    logic_gt: String
    logic_gte: String
    logic_in: [String!]
    logic_lt: String
    logic_lte: String
    logic_not: String
    logic_not_contains: String
    logic_not_contains_nocase: String
    logic_not_ends_with: String
    logic_not_ends_with_nocase: String
    logic_not_in: [String!]
    logic_not_starts_with: String
    logic_not_starts_with_nocase: String
    logic_starts_with: String
    logic_starts_with_nocase: String
    maxValue: Int
    maxValue_gt: Int
    maxValue_gte: Int
    maxValue_in: [Int!]
    maxValue_lt: Int
    maxValue_lte: Int
    maxValue_not: Int
    maxValue_not_in: [Int!]
    minValue: Int
    minValue_gt: Int
    minValue_gte: Int
    minValue_in: [Int!]
    minValue_lt: Int
    minValue_lte: Int
    minValue_not: Int
    minValue_not_in: [Int!]
    or: [DungeonRequirements_filter]
}

input DungeonRunCounterEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonRunCounterEntity_filter]
    count: Int
    count_gt: Int
    count_gte: Int
    count_in: [Int!]
    count_lt: Int
    count_lte: Int
    count_not: Int
    count_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [DungeonRunCounterEntity_filter]
}

input DungeonTreasuryTokenEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonTreasuryTokenEntity_filter]
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [DungeonTreasuryTokenEntity_filter]
    token: String
    token_: TokenAmountEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input EventGenerateInfoData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [EventGenerateInfoData_filter]
    badAttributes: String
    badAttributes_: AttributeGenerateInfo_filter
    badAttributes_contains: String
    badAttributes_contains_nocase: String
    badAttributes_ends_with: String
    badAttributes_ends_with_nocase: String
    badAttributes_gt: String
    badAttributes_gte: String
    badAttributes_in: [String!]
    badAttributes_lt: String
    badAttributes_lte: String
    badAttributes_not: String
    badAttributes_not_contains: String
    badAttributes_not_contains_nocase: String
    badAttributes_not_ends_with: String
    badAttributes_not_ends_with_nocase: String
    badAttributes_not_in: [String!]
    badAttributes_not_starts_with: String
    badAttributes_not_starts_with_nocase: String
    badAttributes_starts_with: String
    badAttributes_starts_with_nocase: String
    biome: Int
    biome_gt: Int
    biome_gte: Int
    biome_in: [Int!]
    biome_lt: Int
    biome_lte: Int
    biome_not: Int
    biome_not_in: [Int!]
    damage: Int
    damage_gt: Int
    damage_gte: Int
    damage_in: [Int!]
    damage_lt: Int
    damage_lte: Int
    damage_not: Int
    damage_not_in: [Int!]
    eventId: Int
    eventId_gt: Int
    eventId_gte: Int
    eventId_in: [Int!]
    eventId_lt: Int
    eventId_lte: Int
    eventId_not: Int
    eventId_not_in: [Int!]
    experience: BigInt
    experience_gt: BigInt
    experience_gte: BigInt
    experience_in: [BigInt!]
    experience_lt: BigInt
    experience_lte: BigInt
    experience_not: BigInt
    experience_not_in: [BigInt!]
    goodAttributes: String
    goodAttributes_: AttributeGenerateInfo_filter
    goodAttributes_contains: String
    goodAttributes_contains_nocase: String
    goodAttributes_ends_with: String
    goodAttributes_ends_with_nocase: String
    goodAttributes_gt: String
    goodAttributes_gte: String
    goodAttributes_in: [String!]
    goodAttributes_lt: String
    goodAttributes_lte: String
    goodAttributes_not: String
    goodAttributes_not_contains: String
    goodAttributes_not_contains_nocase: String
    goodAttributes_not_ends_with: String
    goodAttributes_not_ends_with_nocase: String
    goodAttributes_not_in: [String!]
    goodAttributes_not_starts_with: String
    goodAttributes_not_starts_with_nocase: String
    goodAttributes_starts_with: String
    goodAttributes_starts_with_nocase: String
    goodChance: BigInt
    goodChance_gt: BigInt
    goodChance_gte: BigInt
    goodChance_in: [BigInt!]
    goodChance_lt: BigInt
    goodChance_lte: BigInt
    goodChance_not: BigInt
    goodChance_not_in: [BigInt!]
    heal: Int
    heal_gt: Int
    heal_gte: Int
    heal_in: [Int!]
    heal_lt: Int
    heal_lte: Int
    heal_not: Int
    heal_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lifeChancesRecovered: Int
    lifeChancesRecovered_gt: Int
    lifeChancesRecovered_gte: Int
    lifeChancesRecovered_in: [Int!]
    lifeChancesRecovered_lt: Int
    lifeChancesRecovered_lte: Int
    lifeChancesRecovered_not: Int
    lifeChancesRecovered_not_in: [Int!]
    manaConsumed: Int
    manaConsumed_gt: Int
    manaConsumed_gte: Int
    manaConsumed_in: [Int!]
    manaConsumed_lt: Int
    manaConsumed_lte: Int
    manaConsumed_not: Int
    manaConsumed_not_in: [Int!]
    manaRegen: Int
    manaRegen_gt: Int
    manaRegen_gte: Int
    manaRegen_in: [Int!]
    manaRegen_lt: Int
    manaRegen_lte: Int
    manaRegen_not: Int
    manaRegen_not_in: [Int!]
    mintItems: [String!]
    mintItemsChances: [BigInt!]
    mintItemsChances_contains: [BigInt!]
    mintItemsChances_contains_nocase: [BigInt!]
    mintItemsChances_not: [BigInt!]
    mintItemsChances_not_contains: [BigInt!]
    mintItemsChances_not_contains_nocase: [BigInt!]
    mintItems_contains: [String!]
    mintItems_contains_nocase: [String!]
    mintItems_not: [String!]
    mintItems_not_contains: [String!]
    mintItems_not_contains_nocase: [String!]
    or: [EventGenerateInfoData_filter]
    subType: Int
    subType_gt: Int
    subType_gte: Int
    subType_in: [Int!]
    subType_lt: Int
    subType_lte: Int
    subType_not: Int
    subType_not_in: [Int!]
}

input EventGenerateInfoNegativeStatData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [EventGenerateInfoNegativeStatData_filter]
    damage: BigInt
    damage_gt: BigInt
    damage_gte: BigInt
    damage_in: [BigInt!]
    damage_lt: BigInt
    damage_lte: BigInt
    damage_not: BigInt
    damage_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    manaConsumed: BigInt
    manaConsumed_gt: BigInt
    manaConsumed_gte: BigInt
    manaConsumed_in: [BigInt!]
    manaConsumed_lt: BigInt
    manaConsumed_lte: BigInt
    manaConsumed_not: BigInt
    manaConsumed_not_in: [BigInt!]
    or: [EventGenerateInfoNegativeStatData_filter]
}

input EventGenerateInfoPositiveStatData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [EventGenerateInfoPositiveStatData_filter]
    experience: BigInt
    experience_gt: BigInt
    experience_gte: BigInt
    experience_in: [BigInt!]
    experience_lt: BigInt
    experience_lte: BigInt
    experience_not: BigInt
    experience_not_in: [BigInt!]
    heal: BigInt
    heal_gt: BigInt
    heal_gte: BigInt
    heal_in: [BigInt!]
    heal_lt: BigInt
    heal_lte: BigInt
    heal_not: BigInt
    heal_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lifeChancesRecovered: BigInt
    lifeChancesRecovered_gt: BigInt
    lifeChancesRecovered_gte: BigInt
    lifeChancesRecovered_in: [BigInt!]
    lifeChancesRecovered_lt: BigInt
    lifeChancesRecovered_lte: BigInt
    lifeChancesRecovered_not: BigInt
    lifeChancesRecovered_not_in: [BigInt!]
    manaRegen: BigInt
    manaRegen_gt: BigInt
    manaRegen_gte: BigInt
    manaRegen_in: [BigInt!]
    manaRegen_lt: BigInt
    manaRegen_lte: BigInt
    manaRegen_not: BigInt
    manaRegen_not_in: [BigInt!]
    or: [EventGenerateInfoPositiveStatData_filter]
}

input EventResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [EventResultEntity_filter]
    damage: Int
    damage_gt: Int
    damage_gte: Int
    damage_in: [Int!]
    damage_lt: Int
    damage_lte: Int
    damage_not: Int
    damage_not_in: [Int!]
    experience: Int
    experience_gt: Int
    experience_gte: Int
    experience_in: [Int!]
    experience_lt: Int
    experience_lte: Int
    experience_not: Int
    experience_not_in: [Int!]
    heal: Int
    heal_gt: Int
    heal_gte: Int
    heal_in: [Int!]
    heal_lt: Int
    heal_lte: Int
    heal_not: Int
    heal_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lifeChancesRecovered: Int
    lifeChancesRecovered_gt: Int
    lifeChancesRecovered_gte: Int
    lifeChancesRecovered_in: [Int!]
    lifeChancesRecovered_lt: Int
    lifeChancesRecovered_lte: Int
    lifeChancesRecovered_not: Int
    lifeChancesRecovered_not_in: [Int!]
    manaConsumed: Int
    manaConsumed_gt: Int
    manaConsumed_gte: Int
    manaConsumed_in: [Int!]
    manaConsumed_lt: Int
    manaConsumed_lte: Int
    manaConsumed_not: Int
    manaConsumed_not_in: [Int!]
    manaRegen: Int
    manaRegen_gt: Int
    manaRegen_gte: Int
    manaRegen_in: [Int!]
    manaRegen_lt: Int
    manaRegen_lte: Int
    manaRegen_not: Int
    manaRegen_not_in: [Int!]
    negAttributes: [BigDecimal!]
    negAttributes_contains: [BigDecimal!]
    negAttributes_contains_nocase: [BigDecimal!]
    negAttributes_not: [BigDecimal!]
    negAttributes_not_contains: [BigDecimal!]
    negAttributes_not_contains_nocase: [BigDecimal!]
    or: [EventResultEntity_filter]
    posAttributes: [BigDecimal!]
    posAttributes_contains: [BigDecimal!]
    posAttributes_contains_nocase: [BigDecimal!]
    posAttributes_not: [BigDecimal!]
    posAttributes_not_contains: [BigDecimal!]
    posAttributes_not_contains_nocase: [BigDecimal!]
}

input FightResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FightResultEntity_filter]
    fighterA: String
    fighterA_: FighterTurnResultEntity_filter
    fighterA_contains: String
    fighterA_contains_nocase: String
    fighterA_ends_with: String
    fighterA_ends_with_nocase: String
    fighterA_gt: String
    fighterA_gte: String
    fighterA_in: [String!]
    fighterA_lt: String
    fighterA_lte: String
    fighterA_not: String
    fighterA_not_contains: String
    fighterA_not_contains_nocase: String
    fighterA_not_ends_with: String
    fighterA_not_ends_with_nocase: String
    fighterA_not_in: [String!]
    fighterA_not_starts_with: String
    fighterA_not_starts_with_nocase: String
    fighterA_starts_with: String
    fighterA_starts_with_nocase: String
    fighterB: String
    fighterB_: FighterTurnResultEntity_filter
    fighterB_contains: String
    fighterB_contains_nocase: String
    fighterB_ends_with: String
    fighterB_ends_with_nocase: String
    fighterB_gt: String
    fighterB_gte: String
    fighterB_in: [String!]
    fighterB_lt: String
    fighterB_lte: String
    fighterB_not: String
    fighterB_not_contains: String
    fighterB_not_contains_nocase: String
    fighterB_not_ends_with: String
    fighterB_not_ends_with_nocase: String
    fighterB_not_in: [String!]
    fighterB_not_starts_with: String
    fighterB_not_starts_with_nocase: String
    fighterB_starts_with: String
    fighterB_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [FightResultEntity_filter]
    result: String
    result_: ChamberActionResultEntity_filter
    result_contains: String
    result_contains_nocase: String
    result_ends_with: String
    result_ends_with_nocase: String
    result_gt: String
    result_gte: String
    result_in: [String!]
    result_lt: String
    result_lte: String
    result_not: String
    result_not_contains: String
    result_not_contains_nocase: String
    result_not_ends_with: String
    result_not_ends_with_nocase: String
    result_not_in: [String!]
    result_not_starts_with: String
    result_not_starts_with_nocase: String
    result_starts_with: String
    result_starts_with_nocase: String
}

input FighterInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FighterInfoEntity_filter]
    attackToken: String
    attackToken_: ItemEntity_filter
    attackToken_contains: String
    attackToken_contains_nocase: String
    attackToken_ends_with: String
    attackToken_ends_with_nocase: String
    attackToken_gt: String
    attackToken_gte: String
    attackToken_in: [String!]
    attackToken_lt: String
    attackToken_lte: String
    attackToken_not: String
    attackToken_not_contains: String
    attackToken_not_contains_nocase: String
    attackToken_not_ends_with: String
    attackToken_not_ends_with_nocase: String
    attackToken_not_in: [String!]
    attackToken_not_starts_with: String
    attackToken_not_starts_with_nocase: String
    attackToken_starts_with: String
    attackToken_starts_with_nocase: String
    attackType: Int
    attackType_gt: Int
    attackType_gte: Int
    attackType_in: [Int!]
    attackType_lt: Int
    attackType_lte: Int
    attackType_not: Int
    attackType_not_in: [Int!]
    fighterAttributes: [BigDecimal!]
    fighterAttributes_contains: [BigDecimal!]
    fighterAttributes_contains_nocase: [BigDecimal!]
    fighterAttributes_not: [BigDecimal!]
    fighterAttributes_not_contains: [BigDecimal!]
    fighterAttributes_not_contains_nocase: [BigDecimal!]
    fighterStats: String
    fighterStats_: StatsEntity_filter
    fighterStats_contains: String
    fighterStats_contains_nocase: String
    fighterStats_ends_with: String
    fighterStats_ends_with_nocase: String
    fighterStats_gt: String
    fighterStats_gte: String
    fighterStats_in: [String!]
    fighterStats_lt: String
    fighterStats_lte: String
    fighterStats_not: String
    fighterStats_not_contains: String
    fighterStats_not_contains_nocase: String
    fighterStats_not_ends_with: String
    fighterStats_not_ends_with_nocase: String
    fighterStats_not_in: [String!]
    fighterStats_not_starts_with: String
    fighterStats_not_starts_with_nocase: String
    fighterStats_starts_with: String
    fighterStats_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [FighterInfoEntity_filter]
    race: Int
    race_gt: Int
    race_gte: Int
    race_in: [Int!]
    race_lt: Int
    race_lte: Int
    race_not: Int
    race_not_in: [Int!]
}

input FighterTurnResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [FighterTurnResultEntity_filter]
    damage: Int
    damagePoison: Int
    damagePoison_gt: Int
    damagePoison_gte: Int
    damagePoison_in: [Int!]
    damagePoison_lt: Int
    damagePoison_lte: Int
    damagePoison_not: Int
    damagePoison_not_in: [Int!]
    damageReflect: Int
    damageReflect_gt: Int
    damageReflect_gte: Int
    damageReflect_in: [Int!]
    damageReflect_lt: Int
    damageReflect_lte: Int
    damageReflect_not: Int
    damageReflect_not_in: [Int!]
    damage_gt: Int
    damage_gte: Int
    damage_in: [Int!]
    damage_lt: Int
    damage_lte: Int
    damage_not: Int
    damage_not_in: [Int!]
    health: Int
    health_gt: Int
    health_gte: Int
    health_in: [Int!]
    health_lt: Int
    health_lte: Int
    health_not: Int
    health_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    info: String
    info_: FighterInfoEntity_filter
    info_contains: String
    info_contains_nocase: String
    info_ends_with: String
    info_ends_with_nocase: String
    info_gt: String
    info_gte: String
    info_in: [String!]
    info_lt: String
    info_lte: String
    info_not: String
    info_not_contains: String
    info_not_contains_nocase: String
    info_not_ends_with: String
    info_not_ends_with_nocase: String
    info_not_in: [String!]
    info_not_starts_with: String
    info_not_starts_with_nocase: String
    info_starts_with: String
    info_starts_with_nocase: String
    magicAttack: String
    magicAttack_: ItemMagicAttackInfoEntity_filter
    magicAttack_contains: String
    magicAttack_contains_nocase: String
    magicAttack_ends_with: String
    magicAttack_ends_with_nocase: String
    magicAttack_gt: String
    magicAttack_gte: String
    magicAttack_in: [String!]
    magicAttack_lt: String
    magicAttack_lte: String
    magicAttack_not: String
    magicAttack_not_contains: String
    magicAttack_not_contains_nocase: String
    magicAttack_not_ends_with: String
    magicAttack_not_ends_with_nocase: String
    magicAttack_not_in: [String!]
    magicAttack_not_starts_with: String
    magicAttack_not_starts_with_nocase: String
    magicAttack_starts_with: String
    magicAttack_starts_with_nocase: String
    manaConsumed: Int
    manaConsumed_gt: Int
    manaConsumed_gte: Int
    manaConsumed_in: [Int!]
    manaConsumed_lt: Int
    manaConsumed_lte: Int
    manaConsumed_not: Int
    manaConsumed_not_in: [Int!]
    or: [FighterTurnResultEntity_filter]
    statuses: String
    statuses_: StatusesEntity_filter
    statuses_contains: String
    statuses_contains_nocase: String
    statuses_ends_with: String
    statuses_ends_with_nocase: String
    statuses_gt: String
    statuses_gte: String
    statuses_in: [String!]
    statuses_lt: String
    statuses_lte: String
    statuses_not: String
    statuses_not_contains: String
    statuses_not_contains_nocase: String
    statuses_not_ends_with: String
    statuses_not_ends_with_nocase: String
    statuses_not_in: [String!]
    statuses_not_starts_with: String
    statuses_not_starts_with_nocase: String
    statuses_starts_with: String
    statuses_starts_with_nocase: String
}

input GeneralHeroTokenEarned_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [GeneralHeroTokenEarned_filter]
    countAmount: Int
    countAmount_gt: Int
    countAmount_gte: Int
    countAmount_in: [Int!]
    countAmount_lt: Int
    countAmount_lte: Int
    countAmount_not: Int
    countAmount_not_in: [Int!]
    countReinforcementRewards: Int
    countReinforcementRewards_gt: Int
    countReinforcementRewards_gte: Int
    countReinforcementRewards_in: [Int!]
    countReinforcementRewards_lt: Int
    countReinforcementRewards_lte: Int
    countReinforcementRewards_not: Int
    countReinforcementRewards_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [GeneralHeroTokenEarned_filter]
    totalAmount: BigInt
    totalAmount_gt: BigInt
    totalAmount_gte: BigInt
    totalAmount_in: [BigInt!]
    totalAmount_lt: BigInt
    totalAmount_lte: BigInt
    totalAmount_not: BigInt
    totalAmount_not_in: [BigInt!]
    totalReinforcementRewards: BigDecimal
    totalReinforcementRewards_gt: BigDecimal
    totalReinforcementRewards_gte: BigDecimal
    totalReinforcementRewards_in: [BigDecimal!]
    totalReinforcementRewards_lt: BigDecimal
    totalReinforcementRewards_lte: BigDecimal
    totalReinforcementRewards_not: BigDecimal
    totalReinforcementRewards_not_in: [BigDecimal!]
}

input GeneralTokenomicsEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [GeneralTokenomicsEntity_filter]
    heroes: Int
    heroesByClass: [Int!]
    heroesByClass_contains: [Int!]
    heroesByClass_contains_nocase: [Int!]
    heroesByClass_not: [Int!]
    heroesByClass_not_contains: [Int!]
    heroesByClass_not_contains_nocase: [Int!]
    heroes_gt: Int
    heroes_gte: Int
    heroes_in: [Int!]
    heroes_lt: Int
    heroes_lte: Int
    heroes_not: Int
    heroes_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    liveHeroes: Int
    liveHeroesByClass: [Int!]
    liveHeroesByClass_contains: [Int!]
    liveHeroesByClass_contains_nocase: [Int!]
    liveHeroesByClass_not: [Int!]
    liveHeroesByClass_not_contains: [Int!]
    liveHeroesByClass_not_contains_nocase: [Int!]
    liveHeroes_gt: Int
    liveHeroes_gte: Int
    liveHeroes_in: [Int!]
    liveHeroes_lt: Int
    liveHeroes_lte: Int
    liveHeroes_not: Int
    liveHeroes_not_in: [Int!]
    or: [GeneralTokenomicsEntity_filter]
    spentOnHero: BigDecimal
    spentOnHero_gt: BigDecimal
    spentOnHero_gte: BigDecimal
    spentOnHero_in: [BigDecimal!]
    spentOnHero_lt: BigDecimal
    spentOnHero_lte: BigDecimal
    spentOnHero_not: BigDecimal
    spentOnHero_not_in: [BigDecimal!]
    spentOnItems: BigDecimal
    spentOnItems_gt: BigDecimal
    spentOnItems_gte: BigDecimal
    spentOnItems_in: [BigDecimal!]
    spentOnItems_lt: BigDecimal
    spentOnItems_lte: BigDecimal
    spentOnItems_not: BigDecimal
    spentOnItems_not_in: [BigDecimal!]
    totalBurned: BigInt
    totalBurned_gt: BigInt
    totalBurned_gte: BigInt
    totalBurned_in: [BigInt!]
    totalBurned_lt: BigInt
    totalBurned_lte: BigInt
    totalBurned_not: BigInt
    totalBurned_not_in: [BigInt!]
    totalMinted: BigInt
    totalMinted_gt: BigInt
    totalMinted_gte: BigInt
    totalMinted_in: [BigInt!]
    totalMinted_lt: BigInt
    totalMinted_lte: BigInt
    totalMinted_not: BigInt
    totalMinted_not_in: [BigInt!]
    users: Int
    users_gt: Int
    users_gte: Int
    users_in: [Int!]
    users_lt: Int
    users_lte: Int
    users_not: Int
    users_not_in: [Int!]
}

input GlobalCustomDataEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [GlobalCustomDataEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [GlobalCustomDataEntity_filter]
    value: BigDecimal
    value_gt: BigDecimal
    value_gte: BigDecimal
    value_in: [BigDecimal!]
    value_lt: BigDecimal
    value_lte: BigDecimal
    value_not: BigDecimal
    value_not_in: [BigDecimal!]
}

input HeroAction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    action: Int
    action_gt: Int
    action_gte: Int
    action_in: [Int!]
    action_lt: Int
    action_lte: Int
    action_not: Int
    action_not_in: [Int!]
    and: [HeroAction_filter]
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroAction_filter]
    owner: String
    owner_: UserEntity_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    values: [String!]
    values_contains: [String!]
    values_contains_nocase: [String!]
    values_not: [String!]
    values_not_contains: [String!]
    values_not_contains_nocase: [String!]
}

input HeroCustomData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HeroCustomData_filter]
    dataIndex: String
    dataIndex_contains: String
    dataIndex_contains_nocase: String
    dataIndex_ends_with: String
    dataIndex_ends_with_nocase: String
    dataIndex_gt: String
    dataIndex_gte: String
    dataIndex_in: [String!]
    dataIndex_lt: String
    dataIndex_lte: String
    dataIndex_not: String
    dataIndex_not_contains: String
    dataIndex_not_contains_nocase: String
    dataIndex_not_ends_with: String
    dataIndex_not_ends_with_nocase: String
    dataIndex_not_in: [String!]
    dataIndex_not_starts_with: String
    dataIndex_not_starts_with_nocase: String
    dataIndex_starts_with: String
    dataIndex_starts_with_nocase: String
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroCustomData_filter]
    value: BigDecimal
    value_gt: BigDecimal
    value_gte: BigDecimal
    value_in: [BigDecimal!]
    value_lt: BigDecimal
    value_lte: BigDecimal
    value_not: BigDecimal
    value_not_in: [BigDecimal!]
}

input HeroEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions_: HeroAction_filter
    and: [HeroEntity_filter]
    attributes: [BigDecimal!]
    attributes_contains: [BigDecimal!]
    attributes_contains_nocase: [BigDecimal!]
    attributes_not: [BigDecimal!]
    attributes_not_contains: [BigDecimal!]
    attributes_not_contains_nocase: [BigDecimal!]
    biome: Int
    biome_gt: Int
    biome_gte: Int
    biome_in: [Int!]
    biome_lt: Int
    biome_lte: Int
    biome_not: Int
    biome_not_in: [Int!]
    burned: Boolean
    burned_in: [Boolean!]
    burned_not: Boolean
    burned_not_in: [Boolean!]
    core: String
    core_: CoreAttributesEntity_filter
    core_contains: String
    core_contains_nocase: String
    core_ends_with: String
    core_ends_with_nocase: String
    core_gt: String
    core_gte: String
    core_in: [String!]
    core_lt: String
    core_lte: String
    core_not: String
    core_not_contains: String
    core_not_contains_nocase: String
    core_not_ends_with: String
    core_not_ends_with_nocase: String
    core_not_in: [String!]
    core_not_starts_with: String
    core_not_starts_with_nocase: String
    core_starts_with: String
    core_starts_with_nocase: String
    customData_: HeroCustomData_filter
    dead: Boolean
    dead_in: [Boolean!]
    dead_not: Boolean
    dead_not_in: [Boolean!]
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    earnedItems_: HeroItemEarned_filter
    earnedTokens_: HeroTokenEarned_filter
    heroId: Int
    heroId_gt: Int
    heroId_gte: Int
    heroId_in: [Int!]
    heroId_lt: Int
    heroId_lte: Int
    heroId_not: Int
    heroId_not_in: [Int!]
    heroStat: String
    heroStat_: HeroStatEntity_filter
    heroStat_contains: String
    heroStat_contains_nocase: String
    heroStat_ends_with: String
    heroStat_ends_with_nocase: String
    heroStat_gt: String
    heroStat_gte: String
    heroStat_in: [String!]
    heroStat_lt: String
    heroStat_lte: String
    heroStat_not: String
    heroStat_not_contains: String
    heroStat_not_contains_nocase: String
    heroStat_not_ends_with: String
    heroStat_not_ends_with_nocase: String
    heroStat_not_in: [String!]
    heroStat_not_starts_with: String
    heroStat_not_starts_with_nocase: String
    heroStat_starts_with: String
    heroStat_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    items_: ItemEntity_filter
    lastFightTs: Int
    lastFightTs_gt: Int
    lastFightTs_gte: Int
    lastFightTs_in: [Int!]
    lastFightTs_lt: Int
    lastFightTs_lte: Int
    lastFightTs_not: Int
    lastFightTs_not_in: [Int!]
    lastTransfer: Int
    lastTransfer_gt: Int
    lastTransfer_gte: Int
    lastTransfer_in: [Int!]
    lastTransfer_lt: Int
    lastTransfer_lte: Int
    lastTransfer_not: Int
    lastTransfer_not_in: [Int!]
    maxBiomeCompleted: Int
    maxBiomeCompleted_gt: Int
    maxBiomeCompleted_gte: Int
    maxBiomeCompleted_in: [Int!]
    maxBiomeCompleted_lt: Int
    maxBiomeCompleted_lte: Int
    maxBiomeCompleted_not: Int
    maxBiomeCompleted_not_in: [Int!]
    meta: String
    meta_: HeroMetaEntity_filter
    meta_contains: String
    meta_contains_nocase: String
    meta_ends_with: String
    meta_ends_with_nocase: String
    meta_gt: String
    meta_gte: String
    meta_in: [String!]
    meta_lt: String
    meta_lte: String
    meta_not: String
    meta_not_contains: String
    meta_not_contains_nocase: String
    meta_not_ends_with: String
    meta_not_ends_with_nocase: String
    meta_not_in: [String!]
    meta_not_starts_with: String
    meta_not_starts_with_nocase: String
    meta_starts_with: String
    meta_starts_with_nocase: String
    nextLevelExperienceRequire: Int
    nextLevelExperienceRequire_gt: Int
    nextLevelExperienceRequire_gte: Int
    nextLevelExperienceRequire_in: [Int!]
    nextLevelExperienceRequire_lt: Int
    nextLevelExperienceRequire_lte: Int
    nextLevelExperienceRequire_not: Int
    nextLevelExperienceRequire_not_in: [Int!]
    openedChambers_: OpenedChamberEntity_filter
    or: [HeroEntity_filter]
    owner: String
    owner_: UserEntity_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    previousLevelExperienceRequire: Int
    previousLevelExperienceRequire_gt: Int
    previousLevelExperienceRequire_gte: Int
    previousLevelExperienceRequire_in: [Int!]
    previousLevelExperienceRequire_lt: Int
    previousLevelExperienceRequire_lte: Int
    previousLevelExperienceRequire_not: Int
    previousLevelExperienceRequire_not_in: [Int!]
    refCode: String
    refCode_contains: String
    refCode_contains_nocase: String
    refCode_ends_with: String
    refCode_ends_with_nocase: String
    refCode_gt: String
    refCode_gte: String
    refCode_in: [String!]
    refCode_lt: String
    refCode_lte: String
    refCode_not: String
    refCode_not_contains: String
    refCode_not_contains_nocase: String
    refCode_not_ends_with: String
    refCode_not_ends_with_nocase: String
    refCode_not_in: [String!]
    refCode_not_starts_with: String
    refCode_not_starts_with_nocase: String
    refCode_starts_with: String
    refCode_starts_with_nocase: String
    reinforcementHelper: String
    reinforcementHelper_: HeroEntity_filter
    reinforcementHelper_contains: String
    reinforcementHelper_contains_nocase: String
    reinforcementHelper_ends_with: String
    reinforcementHelper_ends_with_nocase: String
    reinforcementHelper_gt: String
    reinforcementHelper_gte: String
    reinforcementHelper_in: [String!]
    reinforcementHelper_lt: String
    reinforcementHelper_lte: String
    reinforcementHelper_not: String
    reinforcementHelper_not_contains: String
    reinforcementHelper_not_contains_nocase: String
    reinforcementHelper_not_ends_with: String
    reinforcementHelper_not_ends_with_nocase: String
    reinforcementHelper_not_in: [String!]
    reinforcementHelper_not_starts_with: String
    reinforcementHelper_not_starts_with_nocase: String
    reinforcementHelper_starts_with: String
    reinforcementHelper_starts_with_nocase: String
    reinforcementRewardItems_: ReinforcementRewardItemEntity_filter
    reinforcementRewardTokens_: ReinforcementRewardTokenEntity_filter
    score: Int
    score_gt: Int
    score_gte: Int
    score_in: [Int!]
    score_lt: Int
    score_lte: Int
    score_not: Int
    score_not_in: [Int!]
    staked: Boolean
    stakedFee: Int
    stakedFee_gt: Int
    stakedFee_gte: Int
    stakedFee_in: [Int!]
    stakedFee_lt: Int
    stakedFee_lte: Int
    stakedFee_not: Int
    stakedFee_not_in: [Int!]
    staked_in: [Boolean!]
    staked_not: Boolean
    staked_not_in: [Boolean!]
    stats: String
    stats_: StatsEntity_filter
    stats_contains: String
    stats_contains_nocase: String
    stats_ends_with: String
    stats_ends_with_nocase: String
    stats_gt: String
    stats_gte: String
    stats_in: [String!]
    stats_lt: String
    stats_lte: String
    stats_not: String
    stats_not_contains: String
    stats_not_contains_nocase: String
    stats_not_ends_with: String
    stats_not_ends_with_nocase: String
    stats_not_in: [String!]
    stats_not_starts_with: String
    stats_not_starts_with_nocase: String
    stats_starts_with: String
    stats_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    uniqName: String
    uniqName_contains: String
    uniqName_contains_nocase: String
    uniqName_ends_with: String
    uniqName_ends_with_nocase: String
    uniqName_gt: String
    uniqName_gte: String
    uniqName_in: [String!]
    uniqName_lt: String
    uniqName_lte: String
    uniqName_not: String
    uniqName_not_contains: String
    uniqName_not_contains_nocase: String
    uniqName_not_ends_with: String
    uniqName_not_ends_with_nocase: String
    uniqName_not_in: [String!]
    uniqName_not_starts_with: String
    uniqName_not_starts_with_nocase: String
    uniqName_starts_with: String
    uniqName_starts_with_nocase: String
    uniqUri: String
    uniqUri_contains: String
    uniqUri_contains_nocase: String
    uniqUri_ends_with: String
    uniqUri_ends_with_nocase: String
    uniqUri_gt: String
    uniqUri_gte: String
    uniqUri_in: [String!]
    uniqUri_lt: String
    uniqUri_lte: String
    uniqUri_not: String
    uniqUri_not_contains: String
    uniqUri_not_contains_nocase: String
    uniqUri_not_ends_with: String
    uniqUri_not_ends_with_nocase: String
    uniqUri_not_in: [String!]
    uniqUri_not_starts_with: String
    uniqUri_not_starts_with_nocase: String
    uniqUri_starts_with: String
    uniqUri_starts_with_nocase: String
}

input HeroItemEarned_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HeroItemEarned_filter]
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [HeroItemEarned_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input HeroMetaEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HeroMetaEntity_filter]
    controllable: String
    controllable_: ControllableEntity_filter
    controllable_contains: String
    controllable_contains_nocase: String
    controllable_ends_with: String
    controllable_ends_with_nocase: String
    controllable_gt: String
    controllable_gte: String
    controllable_in: [String!]
    controllable_lt: String
    controllable_lte: String
    controllable_not: String
    controllable_not_contains: String
    controllable_not_contains_nocase: String
    controllable_not_ends_with: String
    controllable_not_ends_with_nocase: String
    controllable_not_in: [String!]
    controllable_not_starts_with: String
    controllable_not_starts_with_nocase: String
    controllable_starts_with: String
    controllable_starts_with_nocase: String
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    feeToken: String
    feeToken_: TokenAmountEntity_filter
    feeToken_contains: String
    feeToken_contains_nocase: String
    feeToken_ends_with: String
    feeToken_ends_with_nocase: String
    feeToken_gt: String
    feeToken_gte: String
    feeToken_in: [String!]
    feeToken_lt: String
    feeToken_lte: String
    feeToken_not: String
    feeToken_not_contains: String
    feeToken_not_contains_nocase: String
    feeToken_not_ends_with: String
    feeToken_not_ends_with_nocase: String
    feeToken_not_in: [String!]
    feeToken_not_starts_with: String
    feeToken_not_starts_with_nocase: String
    feeToken_starts_with: String
    feeToken_starts_with_nocase: String
    heroClass: Int
    heroClass_gt: Int
    heroClass_gte: Int
    heroClass_in: [Int!]
    heroClass_lt: Int
    heroClass_lte: Int
    heroClass_not: Int
    heroClass_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    initialAttributes: String
    initialAttributes_: CoreAttributesEntity_filter
    initialAttributes_contains: String
    initialAttributes_contains_nocase: String
    initialAttributes_ends_with: String
    initialAttributes_ends_with_nocase: String
    initialAttributes_gt: String
    initialAttributes_gte: String
    initialAttributes_in: [String!]
    initialAttributes_lt: String
    initialAttributes_lte: String
    initialAttributes_not: String
    initialAttributes_not_contains: String
    initialAttributes_not_contains_nocase: String
    initialAttributes_not_ends_with: String
    initialAttributes_not_ends_with_nocase: String
    initialAttributes_not_in: [String!]
    initialAttributes_not_starts_with: String
    initialAttributes_not_starts_with_nocase: String
    initialAttributes_starts_with: String
    initialAttributes_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [HeroMetaEntity_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    uri: String
    uri_contains: String
    uri_contains_nocase: String
    uri_ends_with: String
    uri_ends_with_nocase: String
    uri_gt: String
    uri_gte: String
    uri_in: [String!]
    uri_lt: String
    uri_lte: String
    uri_not: String
    uri_not_contains: String
    uri_not_contains_nocase: String
    uri_not_ends_with: String
    uri_not_ends_with_nocase: String
    uri_not_in: [String!]
    uri_not_starts_with: String
    uri_not_starts_with_nocase: String
    uri_starts_with: String
    uri_starts_with_nocase: String
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input HeroStatEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HeroStatEntity_filter]
    battles: Int
    battles_gt: Int
    battles_gte: Int
    battles_in: [Int!]
    battles_lt: Int
    battles_lte: Int
    battles_not: Int
    battles_not_in: [Int!]
    dungeonCompleted: Int
    dungeonCompleted_gt: Int
    dungeonCompleted_gte: Int
    dungeonCompleted_in: [Int!]
    dungeonCompleted_lt: Int
    dungeonCompleted_lte: Int
    dungeonCompleted_not: Int
    dungeonCompleted_not_in: [Int!]
    events: Int
    events_gt: Int
    events_gte: Int
    events_in: [Int!]
    events_lt: Int
    events_lte: Int
    events_not: Int
    events_not_in: [Int!]
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemsMinted: Int
    itemsMinted_gt: Int
    itemsMinted_gte: Int
    itemsMinted_in: [Int!]
    itemsMinted_lt: Int
    itemsMinted_lte: Int
    itemsMinted_not: Int
    itemsMinted_not_in: [Int!]
    or: [HeroStatEntity_filter]
    reinforcementTokenEarned: BigInt
    reinforcementTokenEarned_gt: BigInt
    reinforcementTokenEarned_gte: BigInt
    reinforcementTokenEarned_in: [BigInt!]
    reinforcementTokenEarned_lt: BigInt
    reinforcementTokenEarned_lte: BigInt
    reinforcementTokenEarned_not: BigInt
    reinforcementTokenEarned_not_in: [BigInt!]
    stories: Int
    stories_gt: Int
    stories_gte: Int
    stories_in: [Int!]
    stories_lt: Int
    stories_lte: Int
    stories_not: Int
    stories_not_in: [Int!]
    tokenEarned: BigInt
    tokenEarned_gt: BigInt
    tokenEarned_gte: BigInt
    tokenEarned_in: [BigInt!]
    tokenEarned_lt: BigInt
    tokenEarned_lte: BigInt
    tokenEarned_not: BigInt
    tokenEarned_not_in: [BigInt!]
}

input HeroTokenEarned_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [HeroTokenEarned_filter]
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroTokenEarned_filter]
    reinforcementStakedFee: Int
    reinforcementStakedFee_gt: Int
    reinforcementStakedFee_gte: Int
    reinforcementStakedFee_in: [Int!]
    reinforcementStakedFee_lt: Int
    reinforcementStakedFee_lte: Int
    reinforcementStakedFee_not: Int
    reinforcementStakedFee_not_in: [Int!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input HeroTokensVaultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HeroTokensVaultEntity_filter]
    createdAtBlock: BigInt
    createdAtBlock_gt: BigInt
    createdAtBlock_gte: BigInt
    createdAtBlock_in: [BigInt!]
    createdAtBlock_lt: BigInt
    createdAtBlock_lte: BigInt
    createdAtBlock_not: BigInt
    createdAtBlock_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroTokensVaultEntity_filter]
}

input HeroTokensVaultHistoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [HeroTokensVaultHistoryEntity_filter]
    from: String
    from_: UserEntity_filter
    from_contains: String
    from_contains_nocase: String
    from_ends_with: String
    from_ends_with_nocase: String
    from_gt: String
    from_gte: String
    from_in: [String!]
    from_lt: String
    from_lte: String
    from_not: String
    from_not_contains: String
    from_not_contains_nocase: String
    from_not_ends_with: String
    from_not_ends_with_nocase: String
    from_not_in: [String!]
    from_not_starts_with: String
    from_not_starts_with_nocase: String
    from_starts_with: String
    from_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroTokensVaultHistoryEntity_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    toBurn: BigInt
    toBurn_gt: BigInt
    toBurn_gte: BigInt
    toBurn_in: [BigInt!]
    toBurn_lt: BigInt
    toBurn_lte: BigInt
    toBurn_not: BigInt
    toBurn_not_in: [BigInt!]
    toGov: BigInt
    toGov_gt: BigInt
    toGov_gte: BigInt
    toGov_in: [BigInt!]
    toGov_lt: BigInt
    toGov_lte: BigInt
    toGov_not: BigInt
    toGov_not_in: [BigInt!]
    toTreasury: BigInt
    toTreasury_gt: BigInt
    toTreasury_gte: BigInt
    toTreasury_in: [BigInt!]
    toTreasury_lt: BigInt
    toTreasury_lte: BigInt
    toTreasury_not: BigInt
    toTreasury_not_in: [BigInt!]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input HeroTokensVaultStatisticEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [HeroTokensVaultStatisticEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [HeroTokensVaultStatisticEntity_filter]
    toBurn: BigInt
    toBurn_gt: BigInt
    toBurn_gte: BigInt
    toBurn_in: [BigInt!]
    toBurn_lt: BigInt
    toBurn_lte: BigInt
    toBurn_not: BigInt
    toBurn_not_in: [BigInt!]
    toGov: BigInt
    toGov_gt: BigInt
    toGov_gte: BigInt
    toGov_in: [BigInt!]
    toGov_lt: BigInt
    toGov_lte: BigInt
    toGov_not: BigInt
    toGov_not_in: [BigInt!]
    toTreasury: BigInt
    toTreasury_gt: BigInt
    toTreasury_gte: BigInt
    toTreasury_in: [BigInt!]
    toTreasury_lt: BigInt
    toTreasury_lte: BigInt
    toTreasury_not: BigInt
    toTreasury_not_in: [BigInt!]
}

input ItemActionEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    action: Int
    action_gt: Int
    action_gte: Int
    action_in: [Int!]
    action_lt: Int
    action_lte: Int
    action_not: Int
    action_not_in: [Int!]
    and: [ItemActionEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [ItemActionEntity_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    user: String
    user_: UserEntity_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    values: [String!]
    values_contains: [String!]
    values_contains_nocase: [String!]
    values_not: [String!]
    values_not_contains: [String!]
    values_not_contains_nocase: [String!]
}

input ItemBuffInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemBuffInfoEntity_filter]
    casterAttributes: [BigDecimal!]
    casterAttributes_contains: [BigDecimal!]
    casterAttributes_contains_nocase: [BigDecimal!]
    casterAttributes_not: [BigDecimal!]
    casterAttributes_not_contains: [BigDecimal!]
    casterAttributes_not_contains_nocase: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    manaConsumption: Int
    manaConsumption_gt: Int
    manaConsumption_gte: Int
    manaConsumption_in: [Int!]
    manaConsumption_lt: Int
    manaConsumption_lte: Int
    manaConsumption_not: Int
    manaConsumption_not_in: [Int!]
    or: [ItemBuffInfoEntity_filter]
    targetAttributes: [BigDecimal!]
    targetAttributes_contains: [BigDecimal!]
    targetAttributes_contains_nocase: [BigDecimal!]
    targetAttributes_not: [BigDecimal!]
    targetAttributes_not_contains: [BigDecimal!]
    targetAttributes_not_contains_nocase: [BigDecimal!]
}

input ItemConsumableInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemConsumableInfoEntity_filter]
    attributes: [BigDecimal!]
    attributes_contains: [BigDecimal!]
    attributes_contains_nocase: [BigDecimal!]
    attributes_not: [BigDecimal!]
    attributes_not_contains: [BigDecimal!]
    attributes_not_contains_nocase: [BigDecimal!]
    buffStats: String
    buffStats_: StatsEntity_filter
    buffStats_contains: String
    buffStats_contains_nocase: String
    buffStats_ends_with: String
    buffStats_ends_with_nocase: String
    buffStats_gt: String
    buffStats_gte: String
    buffStats_in: [String!]
    buffStats_lt: String
    buffStats_lte: String
    buffStats_not: String
    buffStats_not_contains: String
    buffStats_not_contains_nocase: String
    buffStats_not_ends_with: String
    buffStats_not_ends_with_nocase: String
    buffStats_not_in: [String!]
    buffStats_not_starts_with: String
    buffStats_not_starts_with_nocase: String
    buffStats_starts_with: String
    buffStats_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [ItemConsumableInfoEntity_filter]
}

input ItemEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions_: ItemActionEntity_filter
    and: [ItemEntity_filter]
    attributes: [BigDecimal!]
    attributes_contains: [BigDecimal!]
    attributes_contains_nocase: [BigDecimal!]
    attributes_not: [BigDecimal!]
    attributes_not_contains: [BigDecimal!]
    attributes_not_contains_nocase: [BigDecimal!]
    augmentationLevel: Int
    augmentationLevel_gt: Int
    augmentationLevel_gte: Int
    augmentationLevel_in: [Int!]
    augmentationLevel_lt: Int
    augmentationLevel_lte: Int
    augmentationLevel_not: Int
    augmentationLevel_not_in: [Int!]
    buffInfo: String
    buffInfo_: ItemBuffInfoEntity_filter
    buffInfo_contains: String
    buffInfo_contains_nocase: String
    buffInfo_ends_with: String
    buffInfo_ends_with_nocase: String
    buffInfo_gt: String
    buffInfo_gte: String
    buffInfo_in: [String!]
    buffInfo_lt: String
    buffInfo_lte: String
    buffInfo_not: String
    buffInfo_not_contains: String
    buffInfo_not_contains_nocase: String
    buffInfo_not_ends_with: String
    buffInfo_not_ends_with_nocase: String
    buffInfo_not_in: [String!]
    buffInfo_not_starts_with: String
    buffInfo_not_starts_with_nocase: String
    buffInfo_starts_with: String
    buffInfo_starts_with_nocase: String
    burned: Boolean
    burned_in: [Boolean!]
    burned_not: Boolean
    burned_not_in: [Boolean!]
    consumableInfo: String
    consumableInfo_: ItemConsumableInfoEntity_filter
    consumableInfo_contains: String
    consumableInfo_contains_nocase: String
    consumableInfo_ends_with: String
    consumableInfo_ends_with_nocase: String
    consumableInfo_gt: String
    consumableInfo_gte: String
    consumableInfo_in: [String!]
    consumableInfo_lt: String
    consumableInfo_lte: String
    consumableInfo_not: String
    consumableInfo_not_contains: String
    consumableInfo_not_contains_nocase: String
    consumableInfo_not_ends_with: String
    consumableInfo_not_ends_with_nocase: String
    consumableInfo_not_in: [String!]
    consumableInfo_not_starts_with: String
    consumableInfo_not_starts_with_nocase: String
    consumableInfo_starts_with: String
    consumableInfo_starts_with_nocase: String
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    durability: Int
    durabilityPercent: Int
    durabilityPercent_gt: Int
    durabilityPercent_gte: Int
    durabilityPercent_in: [Int!]
    durabilityPercent_lt: Int
    durabilityPercent_lte: Int
    durabilityPercent_not: Int
    durabilityPercent_not_in: [Int!]
    durability_gt: Int
    durability_gte: Int
    durability_in: [Int!]
    durability_lt: Int
    durability_lte: Int
    durability_not: Int
    durability_not_in: [Int!]
    equipped: Boolean
    equippedSlot: Int
    equippedSlot_gt: Int
    equippedSlot_gte: Int
    equippedSlot_in: [Int!]
    equippedSlot_lt: Int
    equippedSlot_lte: Int
    equippedSlot_not: Int
    equippedSlot_not_in: [Int!]
    equipped_in: [Boolean!]
    equipped_not: Boolean
    equipped_not_in: [Boolean!]
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemId: Int
    itemId_gt: Int
    itemId_gte: Int
    itemId_in: [Int!]
    itemId_lt: Int
    itemId_lte: Int
    itemId_not: Int
    itemId_not_in: [Int!]
    magicAttackInfo: String
    magicAttackInfo_: ItemMagicAttackInfoEntity_filter
    magicAttackInfo_contains: String
    magicAttackInfo_contains_nocase: String
    magicAttackInfo_ends_with: String
    magicAttackInfo_ends_with_nocase: String
    magicAttackInfo_gt: String
    magicAttackInfo_gte: String
    magicAttackInfo_in: [String!]
    magicAttackInfo_lt: String
    magicAttackInfo_lte: String
    magicAttackInfo_not: String
    magicAttackInfo_not_contains: String
    magicAttackInfo_not_contains_nocase: String
    magicAttackInfo_not_ends_with: String
    magicAttackInfo_not_ends_with_nocase: String
    magicAttackInfo_not_in: [String!]
    magicAttackInfo_not_starts_with: String
    magicAttackInfo_not_starts_with_nocase: String
    magicAttackInfo_starts_with: String
    magicAttackInfo_starts_with_nocase: String
    meta: String
    meta_: ItemMetaEntity_filter
    meta_contains: String
    meta_contains_nocase: String
    meta_ends_with: String
    meta_ends_with_nocase: String
    meta_gt: String
    meta_gte: String
    meta_in: [String!]
    meta_lt: String
    meta_lte: String
    meta_not: String
    meta_not_contains: String
    meta_not_contains_nocase: String
    meta_not_ends_with: String
    meta_not_ends_with_nocase: String
    meta_not_in: [String!]
    meta_not_starts_with: String
    meta_not_starts_with_nocase: String
    meta_starts_with: String
    meta_starts_with_nocase: String
    or: [ItemEntity_filter]
    rarity: Int
    rarity_gt: Int
    rarity_gte: Int
    rarity_in: [Int!]
    rarity_lt: Int
    rarity_lte: Int
    rarity_not: Int
    rarity_not_in: [Int!]
    score: Int
    score_gt: Int
    score_gte: Int
    score_in: [Int!]
    score_lt: Int
    score_lte: Int
    score_not: Int
    score_not_in: [Int!]
    uniqUri: String
    uniqUri_contains: String
    uniqUri_contains_nocase: String
    uniqUri_ends_with: String
    uniqUri_ends_with_nocase: String
    uniqUri_gt: String
    uniqUri_gte: String
    uniqUri_in: [String!]
    uniqUri_lt: String
    uniqUri_lte: String
    uniqUri_not: String
    uniqUri_not_contains: String
    uniqUri_not_contains_nocase: String
    uniqUri_not_ends_with: String
    uniqUri_not_ends_with_nocase: String
    uniqUri_not_in: [String!]
    uniqUri_not_starts_with: String
    uniqUri_not_starts_with_nocase: String
    uniqUri_starts_with: String
    uniqUri_starts_with_nocase: String
    user: String
    user_: UserEntity_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

input ItemMagicAttackInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMagicAttackInfoEntity_filter]
    attackType: Int
    attackType_gt: Int
    attackType_gte: Int
    attackType_in: [Int!]
    attackType_lt: Int
    attackType_lte: Int
    attackType_not: Int
    attackType_not_in: [Int!]
    attributesFactor: String
    attributesFactor_: CoreAttributesEntity_filter
    attributesFactor_contains: String
    attributesFactor_contains_nocase: String
    attributesFactor_ends_with: String
    attributesFactor_ends_with_nocase: String
    attributesFactor_gt: String
    attributesFactor_gte: String
    attributesFactor_in: [String!]
    attributesFactor_lt: String
    attributesFactor_lte: String
    attributesFactor_not: String
    attributesFactor_not_contains: String
    attributesFactor_not_contains_nocase: String
    attributesFactor_not_ends_with: String
    attributesFactor_not_ends_with_nocase: String
    attributesFactor_not_in: [String!]
    attributesFactor_not_starts_with: String
    attributesFactor_not_starts_with_nocase: String
    attributesFactor_starts_with: String
    attributesFactor_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    maxDmg: Int
    maxDmg_gt: Int
    maxDmg_gte: Int
    maxDmg_in: [Int!]
    maxDmg_lt: Int
    maxDmg_lte: Int
    maxDmg_not: Int
    maxDmg_not_in: [Int!]
    minDmg: Int
    minDmg_gt: Int
    minDmg_gte: Int
    minDmg_in: [Int!]
    minDmg_lt: Int
    minDmg_lte: Int
    minDmg_not: Int
    minDmg_not_in: [Int!]
    or: [ItemMagicAttackInfoEntity_filter]
}

input ItemMetaConsumableInfoAttributeEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMetaConsumableInfoAttributeEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ids: [Int!]
    ids_contains: [Int!]
    ids_contains_nocase: [Int!]
    ids_not: [Int!]
    ids_not_contains: [Int!]
    ids_not_contains_nocase: [Int!]
    or: [ItemMetaConsumableInfoAttributeEntity_filter]
    values: [Int!]
    values_contains: [Int!]
    values_contains_nocase: [Int!]
    values_not: [Int!]
    values_not_contains: [Int!]
    values_not_contains_nocase: [Int!]
}

input ItemMetaEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMetaEntity_filter]
    controllable: String
    controllable_: ControllableEntity_filter
    controllable_contains: String
    controllable_contains_nocase: String
    controllable_ends_with: String
    controllable_ends_with_nocase: String
    controllable_gt: String
    controllable_gte: String
    controllable_in: [String!]
    controllable_lt: String
    controllable_lte: String
    controllable_not: String
    controllable_not_contains: String
    controllable_not_contains_nocase: String
    controllable_not_ends_with: String
    controllable_not_ends_with_nocase: String
    controllable_not_in: [String!]
    controllable_not_starts_with: String
    controllable_not_starts_with_nocase: String
    controllable_starts_with: String
    controllable_starts_with_nocase: String
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    durability: Int
    durability_gt: Int
    durability_gte: Int
    durability_in: [Int!]
    durability_lt: Int
    durability_lte: Int
    durability_not: Int
    durability_not_in: [Int!]
    feeToken: String
    feeToken_: TokenAmountEntity_filter
    feeToken_contains: String
    feeToken_contains_nocase: String
    feeToken_ends_with: String
    feeToken_ends_with_nocase: String
    feeToken_gt: String
    feeToken_gte: String
    feeToken_in: [String!]
    feeToken_lt: String
    feeToken_lte: String
    feeToken_not: String
    feeToken_not_contains: String
    feeToken_not_contains_nocase: String
    feeToken_not_ends_with: String
    feeToken_not_ends_with_nocase: String
    feeToken_not_in: [String!]
    feeToken_not_starts_with: String
    feeToken_not_starts_with_nocase: String
    feeToken_starts_with: String
    feeToken_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isAttackItem: Boolean
    isAttackItem_in: [Boolean!]
    isAttackItem_not: Boolean
    isAttackItem_not_in: [Boolean!]
    isBuffItem: Boolean
    isBuffItem_in: [Boolean!]
    isBuffItem_not: Boolean
    isBuffItem_not_in: [Boolean!]
    isConsumableItem: Boolean
    isConsumableItem_in: [Boolean!]
    isConsumableItem_not: Boolean
    isConsumableItem_not_in: [Boolean!]
    itemType: Int
    itemType_gt: Int
    itemType_gte: Int
    itemType_in: [Int!]
    itemType_lt: Int
    itemType_lte: Int
    itemType_not: Int
    itemType_not_in: [Int!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    manaCost: Int
    manaCost_gt: Int
    manaCost_gte: Int
    manaCost_in: [Int!]
    manaCost_lt: Int
    manaCost_lte: Int
    manaCost_not: Int
    manaCost_not_in: [Int!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [ItemMetaEntity_filter]
    params: String
    params_: ItemMetaParamsEntity_filter
    params_contains: String
    params_contains_nocase: String
    params_ends_with: String
    params_ends_with_nocase: String
    params_gt: String
    params_gte: String
    params_in: [String!]
    params_lt: String
    params_lte: String
    params_not: String
    params_not_contains: String
    params_not_contains_nocase: String
    params_not_ends_with: String
    params_not_ends_with_nocase: String
    params_not_in: [String!]
    params_not_starts_with: String
    params_not_starts_with_nocase: String
    params_starts_with: String
    params_starts_with_nocase: String
    pawnshopItemStat_: PawnshopPositionItemStatEntity_filter
    removed: Boolean
    removed_in: [Boolean!]
    removed_not: Boolean
    removed_not_in: [Boolean!]
    requirements: String
    requirements_: CoreAttributesEntity_filter
    requirements_contains: String
    requirements_contains_nocase: String
    requirements_ends_with: String
    requirements_ends_with_nocase: String
    requirements_gt: String
    requirements_gte: String
    requirements_in: [String!]
    requirements_lt: String
    requirements_lte: String
    requirements_not: String
    requirements_not_contains: String
    requirements_not_contains_nocase: String
    requirements_not_ends_with: String
    requirements_not_ends_with_nocase: String
    requirements_not_in: [String!]
    requirements_not_starts_with: String
    requirements_not_starts_with_nocase: String
    requirements_starts_with: String
    requirements_starts_with_nocase: String
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    uri: String
    uri_contains: String
    uri_contains_nocase: String
    uri_ends_with: String
    uri_ends_with_nocase: String
    uri_gt: String
    uri_gte: String
    uri_in: [String!]
    uri_lt: String
    uri_lte: String
    uri_not: String
    uri_not_contains: String
    uri_not_contains_nocase: String
    uri_not_ends_with: String
    uri_not_ends_with_nocase: String
    uri_not_in: [String!]
    uri_not_starts_with: String
    uri_not_starts_with_nocase: String
    uri_starts_with: String
    uri_starts_with_nocase: String
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input ItemMetaGeneralParamsEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMetaGeneralParamsEntity_filter]
    baseDurability: Int
    baseDurability_gt: Int
    baseDurability_gte: Int
    baseDurability_in: [Int!]
    baseDurability_lt: Int
    baseDurability_lte: Int
    baseDurability_not: Int
    baseDurability_not_in: [Int!]
    defaultRarity: Int
    defaultRarity_gt: Int
    defaultRarity_gte: Int
    defaultRarity_in: [Int!]
    defaultRarity_lt: Int
    defaultRarity_lte: Int
    defaultRarity_not: Int
    defaultRarity_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemLevel: Int
    itemLevel_gt: Int
    itemLevel_gte: Int
    itemLevel_in: [Int!]
    itemLevel_lt: Int
    itemLevel_lte: Int
    itemLevel_not: Int
    itemLevel_not_in: [Int!]
    itemMetaType: Int
    itemMetaType_gt: Int
    itemMetaType_gte: Int
    itemMetaType_in: [Int!]
    itemMetaType_lt: Int
    itemMetaType_lte: Int
    itemMetaType_not: Int
    itemMetaType_not_in: [Int!]
    itemType: Int
    itemType_gt: Int
    itemType_gte: Int
    itemType_in: [Int!]
    itemType_lt: Int
    itemType_lte: Int
    itemType_not: Int
    itemType_not_in: [Int!]
    manaCost: BigInt
    manaCost_gt: BigInt
    manaCost_gte: BigInt
    manaCost_in: [BigInt!]
    manaCost_lt: BigInt
    manaCost_lte: BigInt
    manaCost_not: BigInt
    manaCost_not_in: [BigInt!]
    maxRandomAttributes: Int
    maxRandomAttributes_gt: Int
    maxRandomAttributes_gte: Int
    maxRandomAttributes_in: [Int!]
    maxRandomAttributes_lt: Int
    maxRandomAttributes_lte: Int
    maxRandomAttributes_not: Int
    maxRandomAttributes_not_in: [Int!]
    minRandomAttributes: Int
    minRandomAttributes_gt: Int
    minRandomAttributes_gte: Int
    minRandomAttributes_in: [Int!]
    minRandomAttributes_lt: Int
    minRandomAttributes_lte: Int
    minRandomAttributes_not: Int
    minRandomAttributes_not_in: [Int!]
    or: [ItemMetaGeneralParamsEntity_filter]
    requirements: String
    requirements_: CoreAttributesEntity_filter
    requirements_contains: String
    requirements_contains_nocase: String
    requirements_ends_with: String
    requirements_ends_with_nocase: String
    requirements_gt: String
    requirements_gte: String
    requirements_in: [String!]
    requirements_lt: String
    requirements_lte: String
    requirements_not: String
    requirements_not_contains: String
    requirements_not_contains_nocase: String
    requirements_not_ends_with: String
    requirements_not_ends_with_nocase: String
    requirements_not_in: [String!]
    requirements_not_starts_with: String
    requirements_not_starts_with_nocase: String
    requirements_starts_with: String
    requirements_starts_with_nocase: String
}

input ItemMetaGenerateInfo_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMetaGenerateInfo_filter]
    chances: [BigInt!]
    chances_contains: [BigInt!]
    chances_contains_nocase: [BigInt!]
    chances_not: [BigInt!]
    chances_not_contains: [BigInt!]
    chances_not_contains_nocase: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ids: [Int!]
    ids_contains: [Int!]
    ids_contains_nocase: [Int!]
    ids_not: [Int!]
    ids_not_contains: [Int!]
    ids_not_contains_nocase: [Int!]
    maxs: [Int!]
    maxs_contains: [Int!]
    maxs_contains_nocase: [Int!]
    maxs_not: [Int!]
    maxs_not_contains: [Int!]
    maxs_not_contains_nocase: [Int!]
    mins: [Int!]
    mins_contains: [Int!]
    mins_contains_nocase: [Int!]
    mins_not: [Int!]
    mins_not_contains: [Int!]
    mins_not_contains_nocase: [Int!]
    or: [ItemMetaGenerateInfo_filter]
}

input ItemMetaMagicAttackInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    aType: Int
    aType_gt: Int
    aType_gte: Int
    aType_in: [Int!]
    aType_lt: Int
    aType_lte: Int
    aType_not: Int
    aType_not_in: [Int!]
    and: [ItemMetaMagicAttackInfoEntity_filter]
    attributeFactors: String
    attributeFactors_: CoreAttributesEntity_filter
    attributeFactors_contains: String
    attributeFactors_contains_nocase: String
    attributeFactors_ends_with: String
    attributeFactors_ends_with_nocase: String
    attributeFactors_gt: String
    attributeFactors_gte: String
    attributeFactors_in: [String!]
    attributeFactors_lt: String
    attributeFactors_lte: String
    attributeFactors_not: String
    attributeFactors_not_contains: String
    attributeFactors_not_contains_nocase: String
    attributeFactors_not_ends_with: String
    attributeFactors_not_ends_with_nocase: String
    attributeFactors_not_in: [String!]
    attributeFactors_not_starts_with: String
    attributeFactors_not_starts_with_nocase: String
    attributeFactors_starts_with: String
    attributeFactors_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    max: Int
    max_gt: Int
    max_gte: Int
    max_in: [Int!]
    max_lt: Int
    max_lte: Int
    max_not: Int
    max_not_in: [Int!]
    min: Int
    min_gt: Int
    min_gte: Int
    min_in: [Int!]
    min_lt: Int
    min_lte: Int
    min_not: Int
    min_not_in: [Int!]
    or: [ItemMetaMagicAttackInfoEntity_filter]
}

input ItemMetaParamsEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemMetaParamsEntity_filter]
    augmentAmount: BigInt
    augmentAmount_gt: BigInt
    augmentAmount_gte: BigInt
    augmentAmount_in: [BigInt!]
    augmentAmount_lt: BigInt
    augmentAmount_lte: BigInt
    augmentAmount_not: BigInt
    augmentAmount_not_in: [BigInt!]
    augmentToken: String
    augmentToken_contains: String
    augmentToken_contains_nocase: String
    augmentToken_ends_with: String
    augmentToken_ends_with_nocase: String
    augmentToken_gt: String
    augmentToken_gte: String
    augmentToken_in: [String!]
    augmentToken_lt: String
    augmentToken_lte: String
    augmentToken_not: String
    augmentToken_not_contains: String
    augmentToken_not_contains_nocase: String
    augmentToken_not_ends_with: String
    augmentToken_not_ends_with_nocase: String
    augmentToken_not_in: [String!]
    augmentToken_not_starts_with: String
    augmentToken_not_starts_with_nocase: String
    augmentToken_starts_with: String
    augmentToken_starts_with_nocase: String
    casterAttributes: String
    casterAttributes_: ItemMetaGenerateInfo_filter
    casterAttributes_contains: String
    casterAttributes_contains_nocase: String
    casterAttributes_ends_with: String
    casterAttributes_ends_with_nocase: String
    casterAttributes_gt: String
    casterAttributes_gte: String
    casterAttributes_in: [String!]
    casterAttributes_lt: String
    casterAttributes_lte: String
    casterAttributes_not: String
    casterAttributes_not_contains: String
    casterAttributes_not_contains_nocase: String
    casterAttributes_not_ends_with: String
    casterAttributes_not_ends_with_nocase: String
    casterAttributes_not_in: [String!]
    casterAttributes_not_starts_with: String
    casterAttributes_not_starts_with_nocase: String
    casterAttributes_starts_with: String
    casterAttributes_starts_with_nocase: String
    commonAttributes: String
    commonAttributes_: ItemMetaGenerateInfo_filter
    commonAttributes_contains: String
    commonAttributes_contains_nocase: String
    commonAttributes_ends_with: String
    commonAttributes_ends_with_nocase: String
    commonAttributes_gt: String
    commonAttributes_gte: String
    commonAttributes_in: [String!]
    commonAttributes_lt: String
    commonAttributes_lte: String
    commonAttributes_not: String
    commonAttributes_not_contains: String
    commonAttributes_not_contains_nocase: String
    commonAttributes_not_ends_with: String
    commonAttributes_not_ends_with_nocase: String
    commonAttributes_not_in: [String!]
    commonAttributes_not_starts_with: String
    commonAttributes_not_starts_with_nocase: String
    commonAttributes_starts_with: String
    commonAttributes_starts_with_nocase: String
    consumableAttributes: String
    consumableAttributes_: ItemMetaConsumableInfoAttributeEntity_filter
    consumableAttributes_contains: String
    consumableAttributes_contains_nocase: String
    consumableAttributes_ends_with: String
    consumableAttributes_ends_with_nocase: String
    consumableAttributes_gt: String
    consumableAttributes_gte: String
    consumableAttributes_in: [String!]
    consumableAttributes_lt: String
    consumableAttributes_lte: String
    consumableAttributes_not: String
    consumableAttributes_not_contains: String
    consumableAttributes_not_contains_nocase: String
    consumableAttributes_not_ends_with: String
    consumableAttributes_not_ends_with_nocase: String
    consumableAttributes_not_in: [String!]
    consumableAttributes_not_starts_with: String
    consumableAttributes_not_starts_with_nocase: String
    consumableAttributes_starts_with: String
    consumableAttributes_starts_with_nocase: String
    consumableStats: String
    consumableStats_: StatsMetaEntity_filter
    consumableStats_contains: String
    consumableStats_contains_nocase: String
    consumableStats_ends_with: String
    consumableStats_ends_with_nocase: String
    consumableStats_gt: String
    consumableStats_gte: String
    consumableStats_in: [String!]
    consumableStats_lt: String
    consumableStats_lte: String
    consumableStats_not: String
    consumableStats_not_contains: String
    consumableStats_not_contains_nocase: String
    consumableStats_not_ends_with: String
    consumableStats_not_ends_with_nocase: String
    consumableStats_not_in: [String!]
    consumableStats_not_starts_with: String
    consumableStats_not_starts_with_nocase: String
    consumableStats_starts_with: String
    consumableStats_starts_with_nocase: String
    genAttackInfo: String
    genAttackInfo_: ItemMetaMagicAttackInfoEntity_filter
    genAttackInfo_contains: String
    genAttackInfo_contains_nocase: String
    genAttackInfo_ends_with: String
    genAttackInfo_ends_with_nocase: String
    genAttackInfo_gt: String
    genAttackInfo_gte: String
    genAttackInfo_in: [String!]
    genAttackInfo_lt: String
    genAttackInfo_lte: String
    genAttackInfo_not: String
    genAttackInfo_not_contains: String
    genAttackInfo_not_contains_nocase: String
    genAttackInfo_not_ends_with: String
    genAttackInfo_not_ends_with_nocase: String
    genAttackInfo_not_in: [String!]
    genAttackInfo_not_starts_with: String
    genAttackInfo_not_starts_with_nocase: String
    genAttackInfo_starts_with: String
    genAttackInfo_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemMeta: String
    itemMeta_: ItemMetaGeneralParamsEntity_filter
    itemMeta_contains: String
    itemMeta_contains_nocase: String
    itemMeta_ends_with: String
    itemMeta_ends_with_nocase: String
    itemMeta_gt: String
    itemMeta_gte: String
    itemMeta_in: [String!]
    itemMeta_lt: String
    itemMeta_lte: String
    itemMeta_not: String
    itemMeta_not_contains: String
    itemMeta_not_contains_nocase: String
    itemMeta_not_ends_with: String
    itemMeta_not_ends_with_nocase: String
    itemMeta_not_in: [String!]
    itemMeta_not_starts_with: String
    itemMeta_not_starts_with_nocase: String
    itemMeta_starts_with: String
    itemMeta_starts_with_nocase: String
    or: [ItemMetaParamsEntity_filter]
    targetAttributes: String
    targetAttributes_: ItemMetaGenerateInfo_filter
    targetAttributes_contains: String
    targetAttributes_contains_nocase: String
    targetAttributes_ends_with: String
    targetAttributes_ends_with_nocase: String
    targetAttributes_gt: String
    targetAttributes_gte: String
    targetAttributes_in: [String!]
    targetAttributes_lt: String
    targetAttributes_lte: String
    targetAttributes_not: String
    targetAttributes_not_contains: String
    targetAttributes_not_contains_nocase: String
    targetAttributes_not_ends_with: String
    targetAttributes_not_ends_with_nocase: String
    targetAttributes_not_in: [String!]
    targetAttributes_not_starts_with: String
    targetAttributes_not_starts_with_nocase: String
    targetAttributes_starts_with: String
    targetAttributes_starts_with_nocase: String
}

input ItemsBurntResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ItemsBurntResultEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [ItemsBurntResultEntity_filter]
    result: String
    result_: ChamberActionResultEntity_filter
    result_contains: String
    result_contains_nocase: String
    result_ends_with: String
    result_ends_with_nocase: String
    result_gt: String
    result_gte: String
    result_in: [String!]
    result_lt: String
    result_lte: String
    result_not: String
    result_not_contains: String
    result_not_contains_nocase: String
    result_not_ends_with: String
    result_not_ends_with_nocase: String
    result_not_in: [String!]
    result_not_starts_with: String
    result_not_starts_with_nocase: String
    result_starts_with: String
    result_starts_with_nocase: String
}

input MonsterGenerateAttackInfoData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MonsterGenerateAttackInfoData_filter]
    attackToken: String
    attackTokenId: BigInt
    attackTokenId_gt: BigInt
    attackTokenId_gte: BigInt
    attackTokenId_in: [BigInt!]
    attackTokenId_lt: BigInt
    attackTokenId_lte: BigInt
    attackTokenId_not: BigInt
    attackTokenId_not_in: [BigInt!]
    attackToken_contains: String
    attackToken_contains_nocase: String
    attackToken_ends_with: String
    attackToken_ends_with_nocase: String
    attackToken_gt: String
    attackToken_gte: String
    attackToken_in: [String!]
    attackToken_lt: String
    attackToken_lte: String
    attackToken_not: String
    attackToken_not_contains: String
    attackToken_not_contains_nocase: String
    attackToken_not_ends_with: String
    attackToken_not_ends_with_nocase: String
    attackToken_not_in: [String!]
    attackToken_not_starts_with: String
    attackToken_not_starts_with_nocase: String
    attackToken_starts_with: String
    attackToken_starts_with_nocase: String
    attackType: Int
    attackType_gt: Int
    attackType_gte: Int
    attackType_in: [Int!]
    attackType_lt: Int
    attackType_lte: Int
    attackType_not: Int
    attackType_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    mintItems: [String!]
    mintItemsChances: [BigInt!]
    mintItemsChances_contains: [BigInt!]
    mintItemsChances_contains_nocase: [BigInt!]
    mintItemsChances_not: [BigInt!]
    mintItemsChances_not_contains: [BigInt!]
    mintItemsChances_not_contains_nocase: [BigInt!]
    mintItems_contains: [String!]
    mintItems_contains_nocase: [String!]
    mintItems_not: [String!]
    mintItems_not_contains: [String!]
    mintItems_not_contains_nocase: [String!]
    or: [MonsterGenerateAttackInfoData_filter]
}

input MonsterGenerateInfoData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MonsterGenerateInfoData_filter]
    attackInfo: String
    attackInfo_: MonsterGenerateAttackInfoData_filter
    attackInfo_contains: String
    attackInfo_contains_nocase: String
    attackInfo_ends_with: String
    attackInfo_ends_with_nocase: String
    attackInfo_gt: String
    attackInfo_gte: String
    attackInfo_in: [String!]
    attackInfo_lt: String
    attackInfo_lte: String
    attackInfo_not: String
    attackInfo_not_contains: String
    attackInfo_not_contains_nocase: String
    attackInfo_not_ends_with: String
    attackInfo_not_ends_with_nocase: String
    attackInfo_not_in: [String!]
    attackInfo_not_starts_with: String
    attackInfo_not_starts_with_nocase: String
    attackInfo_starts_with: String
    attackInfo_starts_with_nocase: String
    biome: Int
    biome_gt: Int
    biome_gte: Int
    biome_in: [Int!]
    biome_lt: Int
    biome_lte: Int
    biome_not: Int
    biome_not_in: [Int!]
    experience: BigInt
    experience_gt: BigInt
    experience_gte: BigInt
    experience_in: [BigInt!]
    experience_lt: BigInt
    experience_lte: BigInt
    experience_not: BigInt
    experience_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ids: [Int!]
    ids_contains: [Int!]
    ids_contains_nocase: [Int!]
    ids_not: [Int!]
    ids_not_contains: [Int!]
    ids_not_contains_nocase: [Int!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    maxDropItems: Int
    maxDropItems_gt: Int
    maxDropItems_gte: Int
    maxDropItems_in: [Int!]
    maxDropItems_lt: Int
    maxDropItems_lte: Int
    maxDropItems_not: Int
    maxDropItems_not_in: [Int!]
    monsterId: Int
    monsterId_gt: Int
    monsterId_gte: Int
    monsterId_in: [Int!]
    monsterId_lt: Int
    monsterId_lte: Int
    monsterId_not: Int
    monsterId_not_in: [Int!]
    or: [MonsterGenerateInfoData_filter]
    race: Int
    race_gt: Int
    race_gte: Int
    race_in: [Int!]
    race_lt: Int
    race_lte: Int
    race_not: Int
    race_not_in: [Int!]
    subType: Int
    subType_gt: Int
    subType_gte: Int
    subType_in: [Int!]
    subType_lt: Int
    subType_lte: Int
    subType_not: Int
    subType_not_in: [Int!]
    values: [Int!]
    values_contains: [Int!]
    values_contains_nocase: [Int!]
    values_not: [Int!]
    values_not_contains: [Int!]
    values_not_contains_nocase: [Int!]
}

input MonsterInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MonsterInfoEntity_filter]
    attackInfo: String
    attackInfo_: AttackInfoEntity_filter
    attackInfo_contains: String
    attackInfo_contains_nocase: String
    attackInfo_ends_with: String
    attackInfo_ends_with_nocase: String
    attackInfo_gt: String
    attackInfo_gte: String
    attackInfo_in: [String!]
    attackInfo_lt: String
    attackInfo_lte: String
    attackInfo_not: String
    attackInfo_not_contains: String
    attackInfo_not_contains_nocase: String
    attackInfo_not_ends_with: String
    attackInfo_not_ends_with_nocase: String
    attackInfo_not_in: [String!]
    attackInfo_not_starts_with: String
    attackInfo_not_starts_with_nocase: String
    attackInfo_starts_with: String
    attackInfo_starts_with_nocase: String
    currentHp: BigDecimal
    currentHp_gt: BigDecimal
    currentHp_gte: BigDecimal
    currentHp_in: [BigDecimal!]
    currentHp_lt: BigDecimal
    currentHp_lte: BigDecimal
    currentHp_not: BigDecimal
    currentHp_not_in: [BigDecimal!]
    experience: Int
    experience_gt: Int
    experience_gte: Int
    experience_in: [Int!]
    experience_lt: Int
    experience_lte: Int
    experience_not: Int
    experience_not_in: [Int!]
    generated: Boolean
    generated_in: [Boolean!]
    generated_not: Boolean
    generated_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    monsterAttributes: [BigDecimal!]
    monsterAttributes_contains: [BigDecimal!]
    monsterAttributes_contains_nocase: [BigDecimal!]
    monsterAttributes_not: [BigDecimal!]
    monsterAttributes_not_contains: [BigDecimal!]
    monsterAttributes_not_contains_nocase: [BigDecimal!]
    or: [MonsterInfoEntity_filter]
    race: Int
    race_gt: Int
    race_gte: Int
    race_in: [Int!]
    race_lt: Int
    race_lte: Int
    race_not: Int
    race_not_in: [Int!]
    rarity: BigDecimal
    rarity_gt: BigDecimal
    rarity_gte: BigDecimal
    rarity_in: [BigDecimal!]
    rarity_lt: BigDecimal
    rarity_lte: BigDecimal
    rarity_not: BigDecimal
    rarity_not_in: [BigDecimal!]
    turn: Int
    turn_gt: Int
    turn_gte: Int
    turn_in: [Int!]
    turn_lt: Int
    turn_lte: Int
    turn_not: Int
    turn_not_in: [Int!]
}

input MonsterMintItemData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MonsterMintItemData_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    mintItems: [String!]
    mintItemsChanges: [BigInt!]
    mintItemsChanges_contains: [BigInt!]
    mintItemsChanges_contains_nocase: [BigInt!]
    mintItemsChanges_not: [BigInt!]
    mintItemsChanges_not_contains: [BigInt!]
    mintItemsChanges_not_contains_nocase: [BigInt!]
    mintItems_contains: [String!]
    mintItems_contains_nocase: [String!]
    mintItems_not: [String!]
    mintItems_not_contains: [String!]
    mintItems_not_contains_nocase: [String!]
    or: [MonsterMintItemData_filter]
}

input OpenedChamberEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions_: ChamberActionResultEntity_filter
    and: [OpenedChamberEntity_filter]
    chamber: String
    chamber_: ChamberEntity_filter
    chamber_contains: String
    chamber_contains_nocase: String
    chamber_ends_with: String
    chamber_ends_with_nocase: String
    chamber_gt: String
    chamber_gte: String
    chamber_in: [String!]
    chamber_lt: String
    chamber_lte: String
    chamber_not: String
    chamber_not_contains: String
    chamber_not_contains_nocase: String
    chamber_not_ends_with: String
    chamber_not_ends_with_nocase: String
    chamber_not_in: [String!]
    chamber_not_starts_with: String
    chamber_not_starts_with_nocase: String
    chamber_starts_with: String
    chamber_starts_with_nocase: String
    completed: Boolean
    completed_in: [Boolean!]
    completed_not: Boolean
    completed_not_in: [Boolean!]
    dungeon: String
    dungeon_: DungeonEntity_filter
    dungeon_contains: String
    dungeon_contains_nocase: String
    dungeon_ends_with: String
    dungeon_ends_with_nocase: String
    dungeon_gt: String
    dungeon_gte: String
    dungeon_in: [String!]
    dungeon_lt: String
    dungeon_lte: String
    dungeon_not: String
    dungeon_not_contains: String
    dungeon_not_contains_nocase: String
    dungeon_not_ends_with: String
    dungeon_not_ends_with_nocase: String
    dungeon_not_in: [String!]
    dungeon_not_starts_with: String
    dungeon_not_starts_with_nocase: String
    dungeon_starts_with: String
    dungeon_starts_with_nocase: String
    enteredHero: String
    enteredHero_: HeroEntity_filter
    enteredHero_contains: String
    enteredHero_contains_nocase: String
    enteredHero_ends_with: String
    enteredHero_ends_with_nocase: String
    enteredHero_gt: String
    enteredHero_gte: String
    enteredHero_in: [String!]
    enteredHero_lt: String
    enteredHero_lte: String
    enteredHero_not: String
    enteredHero_not_contains: String
    enteredHero_not_contains_nocase: String
    enteredHero_not_ends_with: String
    enteredHero_not_ends_with_nocase: String
    enteredHero_not_in: [String!]
    enteredHero_not_starts_with: String
    enteredHero_not_starts_with_nocase: String
    enteredHero_starts_with: String
    enteredHero_starts_with_nocase: String
    event: String
    event_: EventResultEntity_filter
    event_contains: String
    event_contains_nocase: String
    event_ends_with: String
    event_ends_with_nocase: String
    event_gt: String
    event_gte: String
    event_in: [String!]
    event_lt: String
    event_lte: String
    event_not: String
    event_not_contains: String
    event_not_contains_nocase: String
    event_not_ends_with: String
    event_not_ends_with_nocase: String
    event_not_in: [String!]
    event_not_starts_with: String
    event_not_starts_with_nocase: String
    event_starts_with: String
    event_starts_with_nocase: String
    heroAdr: String
    heroAdr_contains: String
    heroAdr_contains_nocase: String
    heroAdr_ends_with: String
    heroAdr_ends_with_nocase: String
    heroAdr_gt: String
    heroAdr_gte: String
    heroAdr_in: [String!]
    heroAdr_lt: String
    heroAdr_lte: String
    heroAdr_not: String
    heroAdr_not_contains: String
    heroAdr_not_contains_nocase: String
    heroAdr_not_ends_with: String
    heroAdr_not_ends_with_nocase: String
    heroAdr_not_in: [String!]
    heroAdr_not_starts_with: String
    heroAdr_not_starts_with_nocase: String
    heroAdr_starts_with: String
    heroAdr_starts_with_nocase: String
    heroId: Int
    heroId_gt: Int
    heroId_gte: Int
    heroId_in: [Int!]
    heroId_lt: Int
    heroId_lte: Int
    heroId_not: Int
    heroId_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    iteration: Int
    iteration_gt: Int
    iteration_gte: Int
    iteration_in: [Int!]
    iteration_lt: Int
    iteration_lte: Int
    iteration_not: Int
    iteration_not_in: [Int!]
    monster: String
    monster_: MonsterInfoEntity_filter
    monster_contains: String
    monster_contains_nocase: String
    monster_ends_with: String
    monster_ends_with_nocase: String
    monster_gt: String
    monster_gte: String
    monster_in: [String!]
    monster_lt: String
    monster_lte: String
    monster_not: String
    monster_not_contains: String
    monster_not_contains_nocase: String
    monster_not_ends_with: String
    monster_not_ends_with_nocase: String
    monster_not_in: [String!]
    monster_not_starts_with: String
    monster_not_starts_with_nocase: String
    monster_starts_with: String
    monster_starts_with_nocase: String
    or: [OpenedChamberEntity_filter]
    pages_: StoryPageEntity_filter
    stage: Int
    stage_gt: Int
    stage_gte: Int
    stage_in: [Int!]
    stage_lt: Int
    stage_lte: Int
    stage_not: Int
    stage_not_in: [Int!]
}

input PawnshopEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PawnshopEntity_filter]
    feeRecipient: String
    feeRecipient_contains: String
    feeRecipient_contains_nocase: String
    feeRecipient_ends_with: String
    feeRecipient_ends_with_nocase: String
    feeRecipient_gt: String
    feeRecipient_gte: String
    feeRecipient_in: [String!]
    feeRecipient_lt: String
    feeRecipient_lte: String
    feeRecipient_not: String
    feeRecipient_not_contains: String
    feeRecipient_not_contains_nocase: String
    feeRecipient_not_ends_with: String
    feeRecipient_not_ends_with_nocase: String
    feeRecipient_not_in: [String!]
    feeRecipient_not_starts_with: String
    feeRecipient_not_starts_with_nocase: String
    feeRecipient_starts_with: String
    feeRecipient_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [PawnshopEntity_filter]
    owner: String
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    platformFee: Int
    platformFee_gt: Int
    platformFee_gte: Int
    platformFee_in: [Int!]
    platformFee_lt: Int
    platformFee_lte: Int
    platformFee_not: Int
    platformFee_not_in: [Int!]
    positionDepositAmount: BigDecimal
    positionDepositAmount_gt: BigDecimal
    positionDepositAmount_gte: BigDecimal
    positionDepositAmount_in: [BigDecimal!]
    positionDepositAmount_lt: BigDecimal
    positionDepositAmount_lte: BigDecimal
    positionDepositAmount_not: BigDecimal
    positionDepositAmount_not_in: [BigDecimal!]
    positionDepositToken: String
    positionDepositToken_: TokenEntity_filter
    positionDepositToken_contains: String
    positionDepositToken_contains_nocase: String
    positionDepositToken_ends_with: String
    positionDepositToken_ends_with_nocase: String
    positionDepositToken_gt: String
    positionDepositToken_gte: String
    positionDepositToken_in: [String!]
    positionDepositToken_lt: String
    positionDepositToken_lte: String
    positionDepositToken_not: String
    positionDepositToken_not_contains: String
    positionDepositToken_not_contains_nocase: String
    positionDepositToken_not_ends_with: String
    positionDepositToken_not_ends_with_nocase: String
    positionDepositToken_not_in: [String!]
    positionDepositToken_not_starts_with: String
    positionDepositToken_not_starts_with_nocase: String
    positionDepositToken_starts_with: String
    positionDepositToken_starts_with_nocase: String
    positions_: PawnshopPositionEntity_filter
}

input PawnshopPositionEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    acquiredAmount: BigDecimal
    acquiredAmount_gt: BigDecimal
    acquiredAmount_gte: BigDecimal
    acquiredAmount_in: [BigDecimal!]
    acquiredAmount_lt: BigDecimal
    acquiredAmount_lte: BigDecimal
    acquiredAmount_not: BigDecimal
    acquiredAmount_not_in: [BigDecimal!]
    acquiredToken: String
    acquiredToken_: TokenEntity_filter
    acquiredToken_contains: String
    acquiredToken_contains_nocase: String
    acquiredToken_ends_with: String
    acquiredToken_ends_with_nocase: String
    acquiredToken_gt: String
    acquiredToken_gte: String
    acquiredToken_in: [String!]
    acquiredToken_lt: String
    acquiredToken_lte: String
    acquiredToken_not: String
    acquiredToken_not_contains: String
    acquiredToken_not_contains_nocase: String
    acquiredToken_not_ends_with: String
    acquiredToken_not_ends_with_nocase: String
    acquiredToken_not_in: [String!]
    acquiredToken_not_starts_with: String
    acquiredToken_not_starts_with_nocase: String
    acquiredToken_starts_with: String
    acquiredToken_starts_with_nocase: String
    actions_: PawnshopPositionHistoryEntity_filter
    and: [PawnshopPositionEntity_filter]
    borrower: String
    borrower_: PawnshopUserEntity_filter
    borrower_contains: String
    borrower_contains_nocase: String
    borrower_ends_with: String
    borrower_ends_with_nocase: String
    borrower_gt: String
    borrower_gte: String
    borrower_in: [String!]
    borrower_lt: String
    borrower_lte: String
    borrower_not: String
    borrower_not_contains: String
    borrower_not_contains_nocase: String
    borrower_not_ends_with: String
    borrower_not_ends_with_nocase: String
    borrower_not_in: [String!]
    borrower_not_starts_with: String
    borrower_not_starts_with_nocase: String
    borrower_starts_with: String
    borrower_starts_with_nocase: String
    collateralAmount: BigDecimal
    collateralAmount_gt: BigDecimal
    collateralAmount_gte: BigDecimal
    collateralAmount_in: [BigDecimal!]
    collateralAmount_lt: BigDecimal
    collateralAmount_lte: BigDecimal
    collateralAmount_not: BigDecimal
    collateralAmount_not_in: [BigDecimal!]
    collateralHero: String
    collateralHero_: HeroEntity_filter
    collateralHero_contains: String
    collateralHero_contains_nocase: String
    collateralHero_ends_with: String
    collateralHero_ends_with_nocase: String
    collateralHero_gt: String
    collateralHero_gte: String
    collateralHero_in: [String!]
    collateralHero_lt: String
    collateralHero_lte: String
    collateralHero_not: String
    collateralHero_not_contains: String
    collateralHero_not_contains_nocase: String
    collateralHero_not_ends_with: String
    collateralHero_not_ends_with_nocase: String
    collateralHero_not_in: [String!]
    collateralHero_not_starts_with: String
    collateralHero_not_starts_with_nocase: String
    collateralHero_starts_with: String
    collateralHero_starts_with_nocase: String
    collateralItem: String
    collateralItem_: ItemEntity_filter
    collateralItem_contains: String
    collateralItem_contains_nocase: String
    collateralItem_ends_with: String
    collateralItem_ends_with_nocase: String
    collateralItem_gt: String
    collateralItem_gte: String
    collateralItem_in: [String!]
    collateralItem_lt: String
    collateralItem_lte: String
    collateralItem_not: String
    collateralItem_not_contains: String
    collateralItem_not_contains_nocase: String
    collateralItem_not_ends_with: String
    collateralItem_not_ends_with_nocase: String
    collateralItem_not_in: [String!]
    collateralItem_not_starts_with: String
    collateralItem_not_starts_with_nocase: String
    collateralItem_starts_with: String
    collateralItem_starts_with_nocase: String
    collateralNft: String
    collateralNftId: BigDecimal
    collateralNftId_gt: BigDecimal
    collateralNftId_gte: BigDecimal
    collateralNftId_in: [BigDecimal!]
    collateralNftId_lt: BigDecimal
    collateralNftId_lte: BigDecimal
    collateralNftId_not: BigDecimal
    collateralNftId_not_in: [BigDecimal!]
    collateralNft_contains: String
    collateralNft_contains_nocase: String
    collateralNft_ends_with: String
    collateralNft_ends_with_nocase: String
    collateralNft_gt: String
    collateralNft_gte: String
    collateralNft_in: [String!]
    collateralNft_lt: String
    collateralNft_lte: String
    collateralNft_not: String
    collateralNft_not_contains: String
    collateralNft_not_contains_nocase: String
    collateralNft_not_ends_with: String
    collateralNft_not_ends_with_nocase: String
    collateralNft_not_in: [String!]
    collateralNft_not_starts_with: String
    collateralNft_not_starts_with_nocase: String
    collateralNft_starts_with: String
    collateralNft_starts_with_nocase: String
    collateralToken: String
    collateralToken_: TokenEntity_filter
    collateralToken_contains: String
    collateralToken_contains_nocase: String
    collateralToken_ends_with: String
    collateralToken_ends_with_nocase: String
    collateralToken_gt: String
    collateralToken_gte: String
    collateralToken_in: [String!]
    collateralToken_lt: String
    collateralToken_lte: String
    collateralToken_not: String
    collateralToken_not_contains: String
    collateralToken_not_contains_nocase: String
    collateralToken_not_ends_with: String
    collateralToken_not_ends_with_nocase: String
    collateralToken_not_in: [String!]
    collateralToken_not_starts_with: String
    collateralToken_not_starts_with_nocase: String
    collateralToken_starts_with: String
    collateralToken_starts_with_nocase: String
    createdBlock: Int
    createdBlock_gt: Int
    createdBlock_gte: Int
    createdBlock_in: [Int!]
    createdBlock_lt: Int
    createdBlock_lte: Int
    createdBlock_not: Int
    createdBlock_not_in: [Int!]
    createdTs: Int
    createdTs_gt: Int
    createdTs_gte: Int
    createdTs_in: [Int!]
    createdTs_lt: Int
    createdTs_lte: Int
    createdTs_not: Int
    createdTs_not_in: [Int!]
    depositAmount: BigDecimal
    depositAmount_gt: BigDecimal
    depositAmount_gte: BigDecimal
    depositAmount_in: [BigDecimal!]
    depositAmount_lt: BigDecimal
    depositAmount_lte: BigDecimal
    depositAmount_not: BigDecimal
    depositAmount_not_in: [BigDecimal!]
    depositToken: String
    depositToken_: TokenEntity_filter
    depositToken_contains: String
    depositToken_contains_nocase: String
    depositToken_ends_with: String
    depositToken_ends_with_nocase: String
    depositToken_gt: String
    depositToken_gte: String
    depositToken_in: [String!]
    depositToken_lt: String
    depositToken_lte: String
    depositToken_not: String
    depositToken_not_contains: String
    depositToken_not_contains_nocase: String
    depositToken_not_ends_with: String
    depositToken_not_ends_with_nocase: String
    depositToken_not_in: [String!]
    depositToken_not_starts_with: String
    depositToken_not_starts_with_nocase: String
    depositToken_starts_with: String
    depositToken_starts_with_nocase: String
    executionLender: String
    executionLender_: PawnshopUserEntity_filter
    executionLender_contains: String
    executionLender_contains_nocase: String
    executionLender_ends_with: String
    executionLender_ends_with_nocase: String
    executionLender_gt: String
    executionLender_gte: String
    executionLender_in: [String!]
    executionLender_lt: String
    executionLender_lte: String
    executionLender_not: String
    executionLender_not_contains: String
    executionLender_not_contains_nocase: String
    executionLender_not_ends_with: String
    executionLender_not_ends_with_nocase: String
    executionLender_not_in: [String!]
    executionLender_not_starts_with: String
    executionLender_not_starts_with_nocase: String
    executionLender_starts_with: String
    executionLender_starts_with_nocase: String
    executionPosEndBlock: Int
    executionPosEndBlock_gt: Int
    executionPosEndBlock_gte: Int
    executionPosEndBlock_in: [Int!]
    executionPosEndBlock_lt: Int
    executionPosEndBlock_lte: Int
    executionPosEndBlock_not: Int
    executionPosEndBlock_not_in: [Int!]
    executionPosEndTs: Int
    executionPosEndTs_gt: Int
    executionPosEndTs_gte: Int
    executionPosEndTs_in: [Int!]
    executionPosEndTs_lt: Int
    executionPosEndTs_lte: Int
    executionPosEndTs_not: Int
    executionPosEndTs_not_in: [Int!]
    executionPosStartBlock: Int
    executionPosStartBlock_gt: Int
    executionPosStartBlock_gte: Int
    executionPosStartBlock_in: [Int!]
    executionPosStartBlock_lt: Int
    executionPosStartBlock_lte: Int
    executionPosStartBlock_not: Int
    executionPosStartBlock_not_in: [Int!]
    executionPosStartTs: Int
    executionPosStartTs_gt: Int
    executionPosStartTs_gte: Int
    executionPosStartTs_in: [Int!]
    executionPosStartTs_lt: Int
    executionPosStartTs_lte: Int
    executionPosStartTs_not: Int
    executionPosStartTs_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    open: Boolean
    open_in: [Boolean!]
    open_not: Boolean
    open_not_in: [Boolean!]
    or: [PawnshopPositionEntity_filter]
    pawnshop: String
    pawnshop_: PawnshopEntity_filter
    pawnshop_contains: String
    pawnshop_contains_nocase: String
    pawnshop_ends_with: String
    pawnshop_ends_with_nocase: String
    pawnshop_gt: String
    pawnshop_gte: String
    pawnshop_in: [String!]
    pawnshop_lt: String
    pawnshop_lte: String
    pawnshop_not: String
    pawnshop_not_contains: String
    pawnshop_not_contains_nocase: String
    pawnshop_not_ends_with: String
    pawnshop_not_ends_with_nocase: String
    pawnshop_not_in: [String!]
    pawnshop_not_starts_with: String
    pawnshop_not_starts_with_nocase: String
    pawnshop_starts_with: String
    pawnshop_starts_with_nocase: String
    posDurationBlocks: Int
    posDurationBlocks_gt: Int
    posDurationBlocks_gte: Int
    posDurationBlocks_in: [Int!]
    posDurationBlocks_lt: Int
    posDurationBlocks_lte: Int
    posDurationBlocks_not: Int
    posDurationBlocks_not_in: [Int!]
    posFee: Int
    posFee_gt: Int
    posFee_gte: Int
    posFee_in: [Int!]
    posFee_lt: Int
    posFee_lte: Int
    posFee_not: Int
    posFee_not_in: [Int!]
    posId: Int
    posId_gt: Int
    posId_gte: Int
    posId_in: [Int!]
    posId_lt: Int
    posId_lte: Int
    posId_not: Int
    posId_not_in: [Int!]
}

input PawnshopPositionHistoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    action: Int
    action_gt: Int
    action_gte: Int
    action_in: [Int!]
    action_lt: Int
    action_lte: Int
    action_not: Int
    action_not_in: [Int!]
    and: [PawnshopPositionHistoryEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemMetaEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [PawnshopPositionHistoryEntity_filter]
    position: String
    position_: PawnshopPositionEntity_filter
    position_contains: String
    position_contains_nocase: String
    position_ends_with: String
    position_ends_with_nocase: String
    position_gt: String
    position_gte: String
    position_in: [String!]
    position_lt: String
    position_lte: String
    position_not: String
    position_not_contains: String
    position_not_contains_nocase: String
    position_not_ends_with: String
    position_not_ends_with_nocase: String
    position_not_in: [String!]
    position_not_starts_with: String
    position_not_starts_with_nocase: String
    position_starts_with: String
    position_starts_with_nocase: String
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    user: String
    user_: UserEntity_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    values: [String!]
    values_contains: [String!]
    values_contains_nocase: [String!]
    values_not: [String!]
    values_not_contains: [String!]
    values_not_contains_nocase: [String!]
}

input PawnshopPositionItemStatEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PawnshopPositionItemStatEntity_filter]
    avg: BigDecimal
    avg_gt: BigDecimal
    avg_gte: BigDecimal
    avg_in: [BigDecimal!]
    avg_lt: BigDecimal
    avg_lte: BigDecimal
    avg_not: BigDecimal
    avg_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemMetaEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    max: BigDecimal
    max_gt: BigDecimal
    max_gte: BigDecimal
    max_in: [BigDecimal!]
    max_lt: BigDecimal
    max_lte: BigDecimal
    max_not: BigDecimal
    max_not_in: [BigDecimal!]
    min: BigDecimal
    min_gt: BigDecimal
    min_gte: BigDecimal
    min_in: [BigDecimal!]
    min_lt: BigDecimal
    min_lte: BigDecimal
    min_not: BigDecimal
    min_not_in: [BigDecimal!]
    or: [PawnshopPositionItemStatEntity_filter]
    prices: [BigDecimal!]
    prices_contains: [BigDecimal!]
    prices_contains_nocase: [BigDecimal!]
    prices_not: [BigDecimal!]
    prices_not_contains: [BigDecimal!]
    prices_not_contains_nocase: [BigDecimal!]
    totalTrades: Int
    totalTrades_gt: Int
    totalTrades_gte: Int
    totalTrades_in: [Int!]
    totalTrades_lt: Int
    totalTrades_lte: Int
    totalTrades_not: Int
    totalTrades_not_in: [Int!]
}

input PawnshopStatisticEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PawnshopStatisticEntity_filter]
    avgClosePrice: BigDecimal
    avgClosePrice_gt: BigDecimal
    avgClosePrice_gte: BigDecimal
    avgClosePrice_in: [BigDecimal!]
    avgClosePrice_lt: BigDecimal
    avgClosePrice_lte: BigDecimal
    avgClosePrice_not: BigDecimal
    avgClosePrice_not_in: [BigDecimal!]
    fees: BigDecimal
    fees_gt: BigDecimal
    fees_gte: BigDecimal
    fees_in: [BigDecimal!]
    fees_lt: BigDecimal
    fees_lte: BigDecimal
    fees_not: BigDecimal
    fees_not_in: [BigDecimal!]
    heroes: Int
    heroes_gt: Int
    heroes_gte: Int
    heroes_in: [Int!]
    heroes_lt: Int
    heroes_lte: Int
    heroes_not: Int
    heroes_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    items: Int
    items_gt: Int
    items_gte: Int
    items_in: [Int!]
    items_lt: Int
    items_lte: Int
    items_not: Int
    items_not_in: [Int!]
    maxClosePrice: BigDecimal
    maxClosePrice_gt: BigDecimal
    maxClosePrice_gte: BigDecimal
    maxClosePrice_in: [BigDecimal!]
    maxClosePrice_lt: BigDecimal
    maxClosePrice_lte: BigDecimal
    maxClosePrice_not: BigDecimal
    maxClosePrice_not_in: [BigDecimal!]
    minClosePrice: BigDecimal
    minClosePrice_gt: BigDecimal
    minClosePrice_gte: BigDecimal
    minClosePrice_in: [BigDecimal!]
    minClosePrice_lt: BigDecimal
    minClosePrice_lte: BigDecimal
    minClosePrice_not: BigDecimal
    minClosePrice_not_in: [BigDecimal!]
    or: [PawnshopStatisticEntity_filter]
    totalPosition: Int
    totalPosition_gt: Int
    totalPosition_gte: Int
    totalPosition_in: [Int!]
    totalPosition_lt: Int
    totalPosition_lte: Int
    totalPosition_not: Int
    totalPosition_not_in: [Int!]
    volume: BigDecimal
    volume_gt: BigDecimal
    volume_gte: BigDecimal
    volume_in: [BigDecimal!]
    volume_lt: BigDecimal
    volume_lte: BigDecimal
    volume_not: BigDecimal
    volume_not_in: [BigDecimal!]
}

input PawnshopUserEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PawnshopUserEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    openedPositions_: PawnshopPositionEntity_filter
    or: [PawnshopUserEntity_filter]
}

input RegisteredNameEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [RegisteredNameEntity_filter]
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [RegisteredNameEntity_filter]
}

input ReinforcementRewardItemEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ReinforcementRewardItemEntity_filter]
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    item: String
    item_: ItemEntity_filter
    item_contains: String
    item_contains_nocase: String
    item_ends_with: String
    item_ends_with_nocase: String
    item_gt: String
    item_gte: String
    item_in: [String!]
    item_lt: String
    item_lte: String
    item_not: String
    item_not_contains: String
    item_not_contains_nocase: String
    item_not_ends_with: String
    item_not_ends_with_nocase: String
    item_not_in: [String!]
    item_not_starts_with: String
    item_not_starts_with_nocase: String
    item_starts_with: String
    item_starts_with_nocase: String
    or: [ReinforcementRewardItemEntity_filter]
}

input ReinforcementRewardTokenEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ReinforcementRewardTokenEntity_filter]
    hero: String
    hero_: HeroEntity_filter
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [ReinforcementRewardTokenEntity_filter]
    tokenInfo: String
    tokenInfo_: TokenAmountEntity_filter
    tokenInfo_contains: String
    tokenInfo_contains_nocase: String
    tokenInfo_ends_with: String
    tokenInfo_ends_with_nocase: String
    tokenInfo_gt: String
    tokenInfo_gte: String
    tokenInfo_in: [String!]
    tokenInfo_lt: String
    tokenInfo_lte: String
    tokenInfo_not: String
    tokenInfo_not_contains: String
    tokenInfo_not_contains_nocase: String
    tokenInfo_not_ends_with: String
    tokenInfo_not_ends_with_nocase: String
    tokenInfo_not_in: [String!]
    tokenInfo_not_starts_with: String
    tokenInfo_not_starts_with_nocase: String
    tokenInfo_starts_with: String
    tokenInfo_starts_with_nocase: String
}

input StatsEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StatsEntity_filter]
    experience: Int
    experience_gt: Int
    experience_gte: Int
    experience_in: [Int!]
    experience_lt: Int
    experience_lte: Int
    experience_not: Int
    experience_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    life: Int
    lifeChances: Int
    lifeChances_gt: Int
    lifeChances_gte: Int
    lifeChances_in: [Int!]
    lifeChances_lt: Int
    lifeChances_lte: Int
    lifeChances_not: Int
    lifeChances_not_in: [Int!]
    life_gt: Int
    life_gte: Int
    life_in: [Int!]
    life_lt: Int
    life_lte: Int
    life_not: Int
    life_not_in: [Int!]
    mana: Int
    mana_gt: Int
    mana_gte: Int
    mana_in: [Int!]
    mana_lt: Int
    mana_lte: Int
    mana_not: Int
    mana_not_in: [Int!]
    or: [StatsEntity_filter]
}

input StatsMetaEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StatsMetaEntity_filter]
    experience: BigInt
    experience_gt: BigInt
    experience_gte: BigInt
    experience_in: [BigInt!]
    experience_lt: BigInt
    experience_lte: BigInt
    experience_not: BigInt
    experience_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    level: BigInt
    level_gt: BigInt
    level_gte: BigInt
    level_in: [BigInt!]
    level_lt: BigInt
    level_lte: BigInt
    level_not: BigInt
    level_not_in: [BigInt!]
    life: BigInt
    lifeChances: BigInt
    lifeChances_gt: BigInt
    lifeChances_gte: BigInt
    lifeChances_in: [BigInt!]
    lifeChances_lt: BigInt
    lifeChances_lte: BigInt
    lifeChances_not: BigInt
    lifeChances_not_in: [BigInt!]
    life_gt: BigInt
    life_gte: BigInt
    life_in: [BigInt!]
    life_lt: BigInt
    life_lte: BigInt
    life_not: BigInt
    life_not_in: [BigInt!]
    mana: BigInt
    mana_gt: BigInt
    mana_gte: BigInt
    mana_in: [BigInt!]
    mana_lt: BigInt
    mana_lte: BigInt
    mana_not: BigInt
    mana_not_in: [BigInt!]
    or: [StatsMetaEntity_filter]
}

input StatusesEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StatusesEntity_filter]
    burn: Boolean
    burn_in: [Boolean!]
    burn_not: Boolean
    burn_not_in: [Boolean!]
    confuse: Boolean
    confuse_in: [Boolean!]
    confuse_not: Boolean
    confuse_not_in: [Boolean!]
    curse: Boolean
    curse_in: [Boolean!]
    curse_not: Boolean
    curse_not_in: [Boolean!]
    freeze: Boolean
    freeze_in: [Boolean!]
    freeze_not: Boolean
    freeze_not_in: [Boolean!]
    gotCriticalHit: Boolean
    gotCriticalHit_in: [Boolean!]
    gotCriticalHit_not: Boolean
    gotCriticalHit_not_in: [Boolean!]
    hitBlocked: Boolean
    hitBlocked_in: [Boolean!]
    hitBlocked_not: Boolean
    hitBlocked_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    missed: Boolean
    missed_in: [Boolean!]
    missed_not: Boolean
    missed_not_in: [Boolean!]
    or: [StatusesEntity_filter]
    poison: Boolean
    poison_in: [Boolean!]
    poison_not: Boolean
    poison_not_in: [Boolean!]
    stun: Boolean
    stun_in: [Boolean!]
    stun_not: Boolean
    stun_not_in: [Boolean!]
}

input StoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryEntity_filter]
    answerAttributeRequirements: String
    answerAttributeRequirements_: StoryMetaAnswerAttributeRequirements_filter
    answerAttributeRequirements_contains: String
    answerAttributeRequirements_contains_nocase: String
    answerAttributeRequirements_ends_with: String
    answerAttributeRequirements_ends_with_nocase: String
    answerAttributeRequirements_gt: String
    answerAttributeRequirements_gte: String
    answerAttributeRequirements_in: [String!]
    answerAttributeRequirements_lt: String
    answerAttributeRequirements_lte: String
    answerAttributeRequirements_not: String
    answerAttributeRequirements_not_contains: String
    answerAttributeRequirements_not_contains_nocase: String
    answerAttributeRequirements_not_ends_with: String
    answerAttributeRequirements_not_ends_with_nocase: String
    answerAttributeRequirements_not_in: [String!]
    answerAttributeRequirements_not_starts_with: String
    answerAttributeRequirements_not_starts_with_nocase: String
    answerAttributeRequirements_starts_with: String
    answerAttributeRequirements_starts_with_nocase: String
    answerAttributes: String
    answerAttributes_: AnswerAttributes_filter
    answerAttributes_contains: String
    answerAttributes_contains_nocase: String
    answerAttributes_ends_with: String
    answerAttributes_ends_with_nocase: String
    answerAttributes_gt: String
    answerAttributes_gte: String
    answerAttributes_in: [String!]
    answerAttributes_lt: String
    answerAttributes_lte: String
    answerAttributes_not: String
    answerAttributes_not_contains: String
    answerAttributes_not_contains_nocase: String
    answerAttributes_not_ends_with: String
    answerAttributes_not_ends_with_nocase: String
    answerAttributes_not_in: [String!]
    answerAttributes_not_starts_with: String
    answerAttributes_not_starts_with_nocase: String
    answerAttributes_starts_with: String
    answerAttributes_starts_with_nocase: String
    answerBurnRandomItemMeta: String
    answerBurnRandomItemMeta_: AnswerBurnRandomItemMeta_filter
    answerBurnRandomItemMeta_contains: String
    answerBurnRandomItemMeta_contains_nocase: String
    answerBurnRandomItemMeta_ends_with: String
    answerBurnRandomItemMeta_ends_with_nocase: String
    answerBurnRandomItemMeta_gt: String
    answerBurnRandomItemMeta_gte: String
    answerBurnRandomItemMeta_in: [String!]
    answerBurnRandomItemMeta_lt: String
    answerBurnRandomItemMeta_lte: String
    answerBurnRandomItemMeta_not: String
    answerBurnRandomItemMeta_not_contains: String
    answerBurnRandomItemMeta_not_contains_nocase: String
    answerBurnRandomItemMeta_not_ends_with: String
    answerBurnRandomItemMeta_not_ends_with_nocase: String
    answerBurnRandomItemMeta_not_in: [String!]
    answerBurnRandomItemMeta_not_starts_with: String
    answerBurnRandomItemMeta_not_starts_with_nocase: String
    answerBurnRandomItemMeta_starts_with: String
    answerBurnRandomItemMeta_starts_with_nocase: String
    answerGlobalCustomDataRequirement: String
    answerGlobalCustomDataRequirement_: StoryMetaAnswerDataRequirement_filter
    answerGlobalCustomDataRequirement_contains: String
    answerGlobalCustomDataRequirement_contains_nocase: String
    answerGlobalCustomDataRequirement_ends_with: String
    answerGlobalCustomDataRequirement_ends_with_nocase: String
    answerGlobalCustomDataRequirement_gt: String
    answerGlobalCustomDataRequirement_gte: String
    answerGlobalCustomDataRequirement_in: [String!]
    answerGlobalCustomDataRequirement_lt: String
    answerGlobalCustomDataRequirement_lte: String
    answerGlobalCustomDataRequirement_not: String
    answerGlobalCustomDataRequirement_not_contains: String
    answerGlobalCustomDataRequirement_not_contains_nocase: String
    answerGlobalCustomDataRequirement_not_ends_with: String
    answerGlobalCustomDataRequirement_not_ends_with_nocase: String
    answerGlobalCustomDataRequirement_not_in: [String!]
    answerGlobalCustomDataRequirement_not_starts_with: String
    answerGlobalCustomDataRequirement_not_starts_with_nocase: String
    answerGlobalCustomDataRequirement_starts_with: String
    answerGlobalCustomDataRequirement_starts_with_nocase: String
    answerHeroCustomDataRequirement: String
    answerHeroCustomDataRequirement_: StoryMetaAnswerDataRequirement_filter
    answerHeroCustomDataRequirement_contains: String
    answerHeroCustomDataRequirement_contains_nocase: String
    answerHeroCustomDataRequirement_ends_with: String
    answerHeroCustomDataRequirement_ends_with_nocase: String
    answerHeroCustomDataRequirement_gt: String
    answerHeroCustomDataRequirement_gte: String
    answerHeroCustomDataRequirement_in: [String!]
    answerHeroCustomDataRequirement_lt: String
    answerHeroCustomDataRequirement_lte: String
    answerHeroCustomDataRequirement_not: String
    answerHeroCustomDataRequirement_not_contains: String
    answerHeroCustomDataRequirement_not_contains_nocase: String
    answerHeroCustomDataRequirement_not_ends_with: String
    answerHeroCustomDataRequirement_not_ends_with_nocase: String
    answerHeroCustomDataRequirement_not_in: [String!]
    answerHeroCustomDataRequirement_not_starts_with: String
    answerHeroCustomDataRequirement_not_starts_with_nocase: String
    answerHeroCustomDataRequirement_starts_with: String
    answerHeroCustomDataRequirement_starts_with_nocase: String
    answerItemRequirements: String
    answerItemRequirements_: StoryMetaAnswerItemRequirements_filter
    answerItemRequirements_contains: String
    answerItemRequirements_contains_nocase: String
    answerItemRequirements_ends_with: String
    answerItemRequirements_ends_with_nocase: String
    answerItemRequirements_gt: String
    answerItemRequirements_gte: String
    answerItemRequirements_in: [String!]
    answerItemRequirements_lt: String
    answerItemRequirements_lte: String
    answerItemRequirements_not: String
    answerItemRequirements_not_contains: String
    answerItemRequirements_not_contains_nocase: String
    answerItemRequirements_not_ends_with: String
    answerItemRequirements_not_ends_with_nocase: String
    answerItemRequirements_not_in: [String!]
    answerItemRequirements_not_starts_with: String
    answerItemRequirements_not_starts_with_nocase: String
    answerItemRequirements_starts_with: String
    answerItemRequirements_starts_with_nocase: String
    answerNextPage: String
    answerNextPage_: StoryMetaAnswerNextPage_filter
    answerNextPage_contains: String
    answerNextPage_contains_nocase: String
    answerNextPage_ends_with: String
    answerNextPage_ends_with_nocase: String
    answerNextPage_gt: String
    answerNextPage_gte: String
    answerNextPage_in: [String!]
    answerNextPage_lt: String
    answerNextPage_lte: String
    answerNextPage_not: String
    answerNextPage_not_contains: String
    answerNextPage_not_contains_nocase: String
    answerNextPage_not_ends_with: String
    answerNextPage_not_ends_with_nocase: String
    answerNextPage_not_in: [String!]
    answerNextPage_not_starts_with: String
    answerNextPage_not_starts_with_nocase: String
    answerNextPage_starts_with: String
    answerNextPage_starts_with_nocase: String
    answerTokenRequirements: String
    answerTokenRequirements_: StoryMetaAnswerTokenRequirements_filter
    answerTokenRequirements_contains: String
    answerTokenRequirements_contains_nocase: String
    answerTokenRequirements_ends_with: String
    answerTokenRequirements_ends_with_nocase: String
    answerTokenRequirements_gt: String
    answerTokenRequirements_gte: String
    answerTokenRequirements_in: [String!]
    answerTokenRequirements_lt: String
    answerTokenRequirements_lte: String
    answerTokenRequirements_not: String
    answerTokenRequirements_not_contains: String
    answerTokenRequirements_not_contains_nocase: String
    answerTokenRequirements_not_ends_with: String
    answerTokenRequirements_not_ends_with_nocase: String
    answerTokenRequirements_not_in: [String!]
    answerTokenRequirements_not_starts_with: String
    answerTokenRequirements_not_starts_with_nocase: String
    answerTokenRequirements_starts_with: String
    answerTokenRequirements_starts_with_nocase: String
    answersMeta: String
    answersMeta_: StoryMetaAnswers_filter
    answersMeta_contains: String
    answersMeta_contains_nocase: String
    answersMeta_ends_with: String
    answersMeta_ends_with_nocase: String
    answersMeta_gt: String
    answersMeta_gte: String
    answersMeta_in: [String!]
    answersMeta_lt: String
    answersMeta_lte: String
    answersMeta_not: String
    answersMeta_not_contains: String
    answersMeta_not_contains_nocase: String
    answersMeta_not_ends_with: String
    answersMeta_not_ends_with_nocase: String
    answersMeta_not_in: [String!]
    answersMeta_not_starts_with: String
    answersMeta_not_starts_with_nocase: String
    answersMeta_starts_with: String
    answersMeta_starts_with_nocase: String
    failGlobalCustomData: String
    failGlobalCustomData_: StoryMetaHeroCustomData_filter
    failGlobalCustomData_contains: String
    failGlobalCustomData_contains_nocase: String
    failGlobalCustomData_ends_with: String
    failGlobalCustomData_ends_with_nocase: String
    failGlobalCustomData_gt: String
    failGlobalCustomData_gte: String
    failGlobalCustomData_in: [String!]
    failGlobalCustomData_lt: String
    failGlobalCustomData_lte: String
    failGlobalCustomData_not: String
    failGlobalCustomData_not_contains: String
    failGlobalCustomData_not_contains_nocase: String
    failGlobalCustomData_not_ends_with: String
    failGlobalCustomData_not_ends_with_nocase: String
    failGlobalCustomData_not_in: [String!]
    failGlobalCustomData_not_starts_with: String
    failGlobalCustomData_not_starts_with_nocase: String
    failGlobalCustomData_starts_with: String
    failGlobalCustomData_starts_with_nocase: String
    failHeroCustomData: String
    failHeroCustomData_: StoryMetaHeroCustomData_filter
    failHeroCustomData_contains: String
    failHeroCustomData_contains_nocase: String
    failHeroCustomData_ends_with: String
    failHeroCustomData_ends_with_nocase: String
    failHeroCustomData_gt: String
    failHeroCustomData_gte: String
    failHeroCustomData_in: [String!]
    failHeroCustomData_lt: String
    failHeroCustomData_lte: String
    failHeroCustomData_not: String
    failHeroCustomData_not_contains: String
    failHeroCustomData_not_contains_nocase: String
    failHeroCustomData_not_ends_with: String
    failHeroCustomData_not_ends_with_nocase: String
    failHeroCustomData_not_in: [String!]
    failHeroCustomData_not_starts_with: String
    failHeroCustomData_not_starts_with_nocase: String
    failHeroCustomData_starts_with: String
    failHeroCustomData_starts_with_nocase: String
    failInfo: String
    failInfo_: StoryMetaInfo_filter
    failInfo_contains: String
    failInfo_contains_nocase: String
    failInfo_ends_with: String
    failInfo_ends_with_nocase: String
    failInfo_gt: String
    failInfo_gte: String
    failInfo_in: [String!]
    failInfo_lt: String
    failInfo_lte: String
    failInfo_not: String
    failInfo_not_contains: String
    failInfo_not_contains_nocase: String
    failInfo_not_ends_with: String
    failInfo_not_ends_with_nocase: String
    failInfo_not_in: [String!]
    failInfo_not_starts_with: String
    failInfo_not_starts_with_nocase: String
    failInfo_starts_with: String
    failInfo_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    minLevel: BigInt
    minLevel_gt: BigInt
    minLevel_gte: BigInt
    minLevel_in: [BigInt!]
    minLevel_lt: BigInt
    minLevel_lte: BigInt
    minLevel_not: BigInt
    minLevel_not_in: [BigInt!]
    nextObjRewriteMeta: String
    nextObjRewriteMeta_: StoryMetaObjectsRewrite_filter
    nextObjRewriteMeta_contains: String
    nextObjRewriteMeta_contains_nocase: String
    nextObjRewriteMeta_ends_with: String
    nextObjRewriteMeta_ends_with_nocase: String
    nextObjRewriteMeta_gt: String
    nextObjRewriteMeta_gte: String
    nextObjRewriteMeta_in: [String!]
    nextObjRewriteMeta_lt: String
    nextObjRewriteMeta_lte: String
    nextObjRewriteMeta_not: String
    nextObjRewriteMeta_not_contains: String
    nextObjRewriteMeta_not_contains_nocase: String
    nextObjRewriteMeta_not_ends_with: String
    nextObjRewriteMeta_not_ends_with_nocase: String
    nextObjRewriteMeta_not_in: [String!]
    nextObjRewriteMeta_not_starts_with: String
    nextObjRewriteMeta_not_starts_with_nocase: String
    nextObjRewriteMeta_starts_with: String
    nextObjRewriteMeta_starts_with_nocase: String
    or: [StoryEntity_filter]
    requiredCustomDataIndex: [Bytes!]
    requiredCustomDataIndex_contains: [Bytes!]
    requiredCustomDataIndex_contains_nocase: [Bytes!]
    requiredCustomDataIndex_not: [Bytes!]
    requiredCustomDataIndex_not_contains: [Bytes!]
    requiredCustomDataIndex_not_contains_nocase: [Bytes!]
    requiredCustomDataIsHero: [Boolean!]
    requiredCustomDataIsHero_contains: [Boolean!]
    requiredCustomDataIsHero_contains_nocase: [Boolean!]
    requiredCustomDataIsHero_not: [Boolean!]
    requiredCustomDataIsHero_not_contains: [Boolean!]
    requiredCustomDataIsHero_not_contains_nocase: [Boolean!]
    requiredCustomDataMaxValue: [BigInt!]
    requiredCustomDataMaxValue_contains: [BigInt!]
    requiredCustomDataMaxValue_contains_nocase: [BigInt!]
    requiredCustomDataMaxValue_not: [BigInt!]
    requiredCustomDataMaxValue_not_contains: [BigInt!]
    requiredCustomDataMaxValue_not_contains_nocase: [BigInt!]
    requiredCustomDataMinValue: [BigInt!]
    requiredCustomDataMinValue_contains: [BigInt!]
    requiredCustomDataMinValue_contains_nocase: [BigInt!]
    requiredCustomDataMinValue_not: [BigInt!]
    requiredCustomDataMinValue_not_contains: [BigInt!]
    requiredCustomDataMinValue_not_contains_nocase: [BigInt!]
    storyId: String
    storyId_contains: String
    storyId_contains_nocase: String
    storyId_ends_with: String
    storyId_ends_with_nocase: String
    storyId_gt: String
    storyId_gte: String
    storyId_in: [String!]
    storyId_lt: String
    storyId_lte: String
    storyId_not: String
    storyId_not_contains: String
    storyId_not_contains_nocase: String
    storyId_not_ends_with: String
    storyId_not_ends_with_nocase: String
    storyId_not_in: [String!]
    storyId_not_starts_with: String
    storyId_not_starts_with_nocase: String
    storyId_starts_with: String
    storyId_starts_with_nocase: String
    successGlobalCustomData: String
    successGlobalCustomData_: StoryMetaHeroCustomData_filter
    successGlobalCustomData_contains: String
    successGlobalCustomData_contains_nocase: String
    successGlobalCustomData_ends_with: String
    successGlobalCustomData_ends_with_nocase: String
    successGlobalCustomData_gt: String
    successGlobalCustomData_gte: String
    successGlobalCustomData_in: [String!]
    successGlobalCustomData_lt: String
    successGlobalCustomData_lte: String
    successGlobalCustomData_not: String
    successGlobalCustomData_not_contains: String
    successGlobalCustomData_not_contains_nocase: String
    successGlobalCustomData_not_ends_with: String
    successGlobalCustomData_not_ends_with_nocase: String
    successGlobalCustomData_not_in: [String!]
    successGlobalCustomData_not_starts_with: String
    successGlobalCustomData_not_starts_with_nocase: String
    successGlobalCustomData_starts_with: String
    successGlobalCustomData_starts_with_nocase: String
    successHeroCustomData: String
    successHeroCustomData_: StoryMetaHeroCustomData_filter
    successHeroCustomData_contains: String
    successHeroCustomData_contains_nocase: String
    successHeroCustomData_ends_with: String
    successHeroCustomData_ends_with_nocase: String
    successHeroCustomData_gt: String
    successHeroCustomData_gte: String
    successHeroCustomData_in: [String!]
    successHeroCustomData_lt: String
    successHeroCustomData_lte: String
    successHeroCustomData_not: String
    successHeroCustomData_not_contains: String
    successHeroCustomData_not_contains_nocase: String
    successHeroCustomData_not_ends_with: String
    successHeroCustomData_not_ends_with_nocase: String
    successHeroCustomData_not_in: [String!]
    successHeroCustomData_not_starts_with: String
    successHeroCustomData_not_starts_with_nocase: String
    successHeroCustomData_starts_with: String
    successHeroCustomData_starts_with_nocase: String
    successInfo: String
    successInfo_: StoryMetaInfo_filter
    successInfo_contains: String
    successInfo_contains_nocase: String
    successInfo_ends_with: String
    successInfo_ends_with_nocase: String
    successInfo_gt: String
    successInfo_gte: String
    successInfo_in: [String!]
    successInfo_lt: String
    successInfo_lte: String
    successInfo_not: String
    successInfo_not_contains: String
    successInfo_not_contains_nocase: String
    successInfo_not_ends_with: String
    successInfo_not_ends_with_nocase: String
    successInfo_not_in: [String!]
    successInfo_not_starts_with: String
    successInfo_not_starts_with_nocase: String
    successInfo_starts_with: String
    successInfo_starts_with_nocase: String
}

input StoryMetaAnswerAttributeRequirements_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswerAttributeRequirements_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    cores: [String!]
    cores_contains: [String!]
    cores_contains_nocase: [String!]
    cores_not: [String!]
    cores_not_contains: [String!]
    cores_not_contains_nocase: [String!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ids: [String!]
    ids_contains: [String!]
    ids_contains_nocase: [String!]
    ids_not: [String!]
    ids_not_contains: [String!]
    ids_not_contains_nocase: [String!]
    or: [StoryMetaAnswerAttributeRequirements_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
    values: [String!]
    values_contains: [String!]
    values_contains_nocase: [String!]
    values_not: [String!]
    values_not_contains: [String!]
    values_not_contains_nocase: [String!]
}

input StoryMetaAnswerDataRequirement_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswerDataRequirement_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    dataIndexes: [String!]
    dataIndexes_contains: [String!]
    dataIndexes_contains_nocase: [String!]
    dataIndexes_not: [String!]
    dataIndexes_not_contains: [String!]
    dataIndexes_not_contains_nocase: [String!]
    dataValuesMax: [String!]
    dataValuesMax_contains: [String!]
    dataValuesMax_contains_nocase: [String!]
    dataValuesMax_not: [String!]
    dataValuesMax_not_contains: [String!]
    dataValuesMax_not_contains_nocase: [String!]
    dataValuesMin: [String!]
    dataValuesMin_contains: [String!]
    dataValuesMin_contains_nocase: [String!]
    dataValuesMin_not: [String!]
    dataValuesMin_not_contains: [String!]
    dataValuesMin_not_contains_nocase: [String!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    mandatory: [String!]
    mandatory_contains: [String!]
    mandatory_contains_nocase: [String!]
    mandatory_not: [String!]
    mandatory_not_contains: [String!]
    mandatory_not_contains_nocase: [String!]
    or: [StoryMetaAnswerDataRequirement_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
}

input StoryMetaAnswerItemRequirements_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswerItemRequirements_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [StoryMetaAnswerItemRequirements_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
    requireItemBurn: [String!]
    requireItemBurn_contains: [String!]
    requireItemBurn_contains_nocase: [String!]
    requireItemBurn_not: [String!]
    requireItemBurn_not_contains: [String!]
    requireItemBurn_not_contains_nocase: [String!]
    requireItemEquipped: [String!]
    requireItemEquipped_contains: [String!]
    requireItemEquipped_contains_nocase: [String!]
    requireItemEquipped_not: [String!]
    requireItemEquipped_not_contains: [String!]
    requireItemEquipped_not_contains_nocase: [String!]
    requireItems: [String!]
    requireItems_contains: [String!]
    requireItems_contains_nocase: [String!]
    requireItems_not: [String!]
    requireItems_not_contains: [String!]
    requireItems_not_contains_nocase: [String!]
}

input StoryMetaAnswerNextPage_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswerNextPage_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    answerNextPageIds: [String!]
    answerNextPageIds_contains: [String!]
    answerNextPageIds_contains_nocase: [String!]
    answerNextPageIds_not: [String!]
    answerNextPageIds_not_contains: [String!]
    answerNextPageIds_not_contains_nocase: [String!]
    answerResultIds: [Int!]
    answerResultIds_contains: [Int!]
    answerResultIds_contains_nocase: [Int!]
    answerResultIds_not: [Int!]
    answerResultIds_not_contains: [Int!]
    answerResultIds_not_contains_nocase: [Int!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [StoryMetaAnswerNextPage_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
}

input StoryMetaAnswerTokenRequirements_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswerTokenRequirements_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [StoryMetaAnswerTokenRequirements_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
    requireAmount: [String!]
    requireAmount_contains: [String!]
    requireAmount_contains_nocase: [String!]
    requireAmount_not: [String!]
    requireAmount_not_contains: [String!]
    requireAmount_not_contains_nocase: [String!]
    requireToken: [String!]
    requireToken_contains: [String!]
    requireToken_contains_nocase: [String!]
    requireToken_not: [String!]
    requireToken_not_contains: [String!]
    requireToken_not_contains_nocase: [String!]
    requireTransfer: [String!]
    requireTransfer_contains: [String!]
    requireTransfer_contains_nocase: [String!]
    requireTransfer_not: [String!]
    requireTransfer_not_contains: [String!]
    requireTransfer_not_contains_nocase: [String!]
}

input StoryMetaAnswers_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaAnswers_filter]
    answerHeroClasses: [Int!]
    answerHeroClasses_contains: [Int!]
    answerHeroClasses_contains_nocase: [Int!]
    answerHeroClasses_not: [Int!]
    answerHeroClasses_not_contains: [Int!]
    answerHeroClasses_not_contains_nocase: [Int!]
    answerIds: [Int!]
    answerIds_contains: [Int!]
    answerIds_contains_nocase: [Int!]
    answerIds_not: [Int!]
    answerIds_not_contains: [Int!]
    answerIds_not_contains_nocase: [Int!]
    answerPageIds: [Int!]
    answerPageIds_contains: [Int!]
    answerPageIds_contains_nocase: [Int!]
    answerPageIds_not: [Int!]
    answerPageIds_not_contains: [Int!]
    answerPageIds_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [StoryMetaAnswers_filter]
}

input StoryMetaHeroCustomData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaHeroCustomData_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    dataIndexes: [String!]
    dataIndexes_contains: [String!]
    dataIndexes_contains_nocase: [String!]
    dataIndexes_not: [String!]
    dataIndexes_not_contains: [String!]
    dataIndexes_not_contains_nocase: [String!]
    dataValues: [String!]
    dataValues_contains: [String!]
    dataValues_contains_nocase: [String!]
    dataValues_not: [String!]
    dataValues_not_contains: [String!]
    dataValues_not_contains_nocase: [String!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [StoryMetaHeroCustomData_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
}

input StoryMetaInfo_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaInfo_filter]
    answerId: [Int!]
    answerId_contains: [Int!]
    answerId_contains_nocase: [Int!]
    answerId_not: [Int!]
    answerId_not_contains: [Int!]
    answerId_not_contains_nocase: [Int!]
    attributeIds: [String!]
    attributeIds_contains: [String!]
    attributeIds_contains_nocase: [String!]
    attributeIds_not: [String!]
    attributeIds_not_contains: [String!]
    attributeIds_not_contains_nocase: [String!]
    attributeValues: [String!]
    attributeValues_contains: [String!]
    attributeValues_contains_nocase: [String!]
    attributeValues_not: [String!]
    attributeValues_not_contains: [String!]
    attributeValues_not_contains_nocase: [String!]
    damage: [Int!]
    damage_contains: [Int!]
    damage_contains_nocase: [Int!]
    damage_not: [Int!]
    damage_not_contains: [Int!]
    damage_not_contains_nocase: [Int!]
    experience: [BigInt!]
    experience_contains: [BigInt!]
    experience_contains_nocase: [BigInt!]
    experience_not: [BigInt!]
    experience_not_contains: [BigInt!]
    experience_not_contains_nocase: [BigInt!]
    heal: [Int!]
    heal_contains: [Int!]
    heal_contains_nocase: [Int!]
    heal_not: [Int!]
    heal_not_contains: [Int!]
    heal_not_contains_nocase: [Int!]
    heroClass: [Int!]
    heroClass_contains: [Int!]
    heroClass_contains_nocase: [Int!]
    heroClass_not: [Int!]
    heroClass_not_contains: [Int!]
    heroClass_not_contains_nocase: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lifeChancesRecovered: [Int!]
    lifeChancesRecovered_contains: [Int!]
    lifeChancesRecovered_contains_nocase: [Int!]
    lifeChancesRecovered_not: [Int!]
    lifeChancesRecovered_not_contains: [Int!]
    lifeChancesRecovered_not_contains_nocase: [Int!]
    manaConsumed: [Int!]
    manaConsumed_contains: [Int!]
    manaConsumed_contains_nocase: [Int!]
    manaConsumed_not: [Int!]
    manaConsumed_not_contains: [Int!]
    manaConsumed_not_contains_nocase: [Int!]
    manaRegen: [Int!]
    manaRegen_contains: [Int!]
    manaRegen_contains_nocase: [Int!]
    manaRegen_not: [Int!]
    manaRegen_not_contains: [Int!]
    manaRegen_not_contains_nocase: [Int!]
    mintItems: [String!]
    mintItemsChances: [String!]
    mintItemsChances_contains: [String!]
    mintItemsChances_contains_nocase: [String!]
    mintItemsChances_not: [String!]
    mintItemsChances_not_contains: [String!]
    mintItemsChances_not_contains_nocase: [String!]
    mintItems_contains: [String!]
    mintItems_contains_nocase: [String!]
    mintItems_not: [String!]
    mintItems_not_contains: [String!]
    mintItems_not_contains_nocase: [String!]
    or: [StoryMetaInfo_filter]
    pageId: [Int!]
    pageId_contains: [Int!]
    pageId_contains_nocase: [Int!]
    pageId_not: [Int!]
    pageId_not_contains: [Int!]
    pageId_not_contains_nocase: [Int!]
}

input StoryMetaObjectsRewrite_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryMetaObjectsRewrite_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nextObjHeroClasses: [Int!]
    nextObjHeroClasses_contains: [Int!]
    nextObjHeroClasses_contains_nocase: [Int!]
    nextObjHeroClasses_not: [Int!]
    nextObjHeroClasses_not_contains: [Int!]
    nextObjHeroClasses_not_contains_nocase: [Int!]
    nextObjIds: [String!]
    nextObjIds_contains: [String!]
    nextObjIds_contains_nocase: [String!]
    nextObjIds_not: [String!]
    nextObjIds_not_contains: [String!]
    nextObjIds_not_contains_nocase: [String!]
    nextObjPageIds: [Int!]
    nextObjPageIds_contains: [Int!]
    nextObjPageIds_contains_nocase: [Int!]
    nextObjPageIds_not: [Int!]
    nextObjPageIds_not_contains: [Int!]
    nextObjPageIds_not_contains_nocase: [Int!]
    or: [StoryMetaObjectsRewrite_filter]
}

input StoryPageEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryPageEntity_filter]
    chamber: String
    chamber_: ChamberEntity_filter
    chamber_contains: String
    chamber_contains_nocase: String
    chamber_ends_with: String
    chamber_ends_with_nocase: String
    chamber_gt: String
    chamber_gte: String
    chamber_in: [String!]
    chamber_lt: String
    chamber_lte: String
    chamber_not: String
    chamber_not_contains: String
    chamber_not_contains_nocase: String
    chamber_not_ends_with: String
    chamber_not_ends_with_nocase: String
    chamber_not_in: [String!]
    chamber_not_starts_with: String
    chamber_not_starts_with_nocase: String
    chamber_starts_with: String
    chamber_starts_with_nocase: String
    createdAtBlock: BigInt
    createdAtBlock_gt: BigInt
    createdAtBlock_gte: BigInt
    createdAtBlock_in: [BigInt!]
    createdAtBlock_lt: BigInt
    createdAtBlock_lte: BigInt
    createdAtBlock_not: BigInt
    createdAtBlock_not_in: [BigInt!]
    heroAdr: String
    heroAdr_contains: String
    heroAdr_contains_nocase: String
    heroAdr_ends_with: String
    heroAdr_ends_with_nocase: String
    heroAdr_gt: String
    heroAdr_gte: String
    heroAdr_in: [String!]
    heroAdr_lt: String
    heroAdr_lte: String
    heroAdr_not: String
    heroAdr_not_contains: String
    heroAdr_not_contains_nocase: String
    heroAdr_not_ends_with: String
    heroAdr_not_ends_with_nocase: String
    heroAdr_not_in: [String!]
    heroAdr_not_starts_with: String
    heroAdr_not_starts_with_nocase: String
    heroAdr_starts_with: String
    heroAdr_starts_with_nocase: String
    heroId: Int
    heroId_gt: Int
    heroId_gte: Int
    heroId_in: [Int!]
    heroId_lt: Int
    heroId_lte: Int
    heroId_not: Int
    heroId_not_in: [Int!]
    heroPage: Int
    heroPage_gt: Int
    heroPage_gte: Int
    heroPage_in: [Int!]
    heroPage_lt: Int
    heroPage_lte: Int
    heroPage_not: Int
    heroPage_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    openChamber: String
    openChamber_: OpenedChamberEntity_filter
    openChamber_contains: String
    openChamber_contains_nocase: String
    openChamber_ends_with: String
    openChamber_ends_with_nocase: String
    openChamber_gt: String
    openChamber_gte: String
    openChamber_in: [String!]
    openChamber_lt: String
    openChamber_lte: String
    openChamber_not: String
    openChamber_not_contains: String
    openChamber_not_contains_nocase: String
    openChamber_not_ends_with: String
    openChamber_not_ends_with_nocase: String
    openChamber_not_in: [String!]
    openChamber_not_starts_with: String
    openChamber_not_starts_with_nocase: String
    openChamber_starts_with: String
    openChamber_starts_with_nocase: String
    or: [StoryPageEntity_filter]
    storyId: Int
    storyId_gt: Int
    storyId_gte: Int
    storyId_in: [Int!]
    storyId_lt: Int
    storyId_lte: Int
    storyId_not: Int
    storyId_not_in: [Int!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input StoryResultEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [StoryResultEntity_filter]
    attributes: [Int!]
    attributes_contains: [Int!]
    attributes_contains_nocase: [Int!]
    attributes_not: [Int!]
    attributes_not_contains: [Int!]
    attributes_not_contains_nocase: [Int!]
    dungeonId: Int
    dungeonId_gt: Int
    dungeonId_gte: Int
    dungeonId_in: [Int!]
    dungeonId_lt: Int
    dungeonId_lte: Int
    dungeonId_not: Int
    dungeonId_not_in: [Int!]
    hero: String
    heroId: BigDecimal
    heroId_gt: BigDecimal
    heroId_gte: BigDecimal
    heroId_in: [BigDecimal!]
    heroId_lt: BigDecimal
    heroId_lte: BigDecimal
    heroId_not: BigDecimal
    heroId_not_in: [BigDecimal!]
    hero_contains: String
    hero_contains_nocase: String
    hero_ends_with: String
    hero_ends_with_nocase: String
    hero_gt: String
    hero_gte: String
    hero_in: [String!]
    hero_lt: String
    hero_lte: String
    hero_not: String
    hero_not_contains: String
    hero_not_contains_nocase: String
    hero_not_ends_with: String
    hero_not_ends_with_nocase: String
    hero_not_in: [String!]
    hero_not_starts_with: String
    hero_not_starts_with_nocase: String
    hero_starts_with: String
    hero_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    iteration: Int
    iteration_gt: Int
    iteration_gte: Int
    iteration_in: [Int!]
    iteration_lt: Int
    iteration_lte: Int
    iteration_not: Int
    iteration_not_in: [Int!]
    objectId: Int
    objectId_gt: Int
    objectId_gte: Int
    objectId_in: [Int!]
    objectId_lt: Int
    objectId_lte: Int
    objectId_not: Int
    objectId_not_in: [Int!]
    or: [StoryResultEntity_filter]
    result: String
    result_: ChamberActionResultEntity_filter
    result_contains: String
    result_contains_nocase: String
    result_ends_with: String
    result_ends_with_nocase: String
    result_gt: String
    result_gte: String
    result_in: [String!]
    result_lt: String
    result_lte: String
    result_not: String
    result_not_contains: String
    result_not_contains_nocase: String
    result_not_ends_with: String
    result_not_ends_with_nocase: String
    result_not_in: [String!]
    result_not_starts_with: String
    result_not_starts_with_nocase: String
    result_starts_with: String
    result_starts_with_nocase: String
    salt: Int
    salt_gt: Int
    salt_gte: Int
    salt_in: [Int!]
    salt_lt: Int
    salt_lte: Int
    salt_not: Int
    salt_not_in: [Int!]
    stage: Int
    stage_gt: Int
    stage_gte: Int
    stage_in: [Int!]
    stage_lt: Int
    stage_lte: Int
    stage_not: Int
    stage_not_in: [Int!]
}

input TokenAmountEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigDecimal
    amount_gt: BigDecimal
    amount_gte: BigDecimal
    amount_in: [BigDecimal!]
    amount_lt: BigDecimal
    amount_lte: BigDecimal
    amount_not: BigDecimal
    amount_not_in: [BigDecimal!]
    and: [TokenAmountEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TokenAmountEntity_filter]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input TokenEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TokenEntity_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [TokenEntity_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    totalSupply: BigInt
    totalSupply_gt: BigInt
    totalSupply_gte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_lt: BigInt
    totalSupply_lte: BigInt
    totalSupply_not: BigInt
    totalSupply_not_in: [BigInt!]
}

input TokenTransactionEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [TokenTransactionEntity_filter]
    createdAtBlock: BigInt
    createdAtBlock_gt: BigInt
    createdAtBlock_gte: BigInt
    createdAtBlock_in: [BigInt!]
    createdAtBlock_lt: BigInt
    createdAtBlock_lte: BigInt
    createdAtBlock_not: BigInt
    createdAtBlock_not_in: [BigInt!]
    from: String
    from_contains: String
    from_contains_nocase: String
    from_ends_with: String
    from_ends_with_nocase: String
    from_gt: String
    from_gte: String
    from_in: [String!]
    from_lt: String
    from_lte: String
    from_not: String
    from_not_contains: String
    from_not_contains_nocase: String
    from_not_ends_with: String
    from_not_ends_with_nocase: String
    from_not_in: [String!]
    from_not_starts_with: String
    from_not_starts_with_nocase: String
    from_starts_with: String
    from_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TokenTransactionEntity_filter]
    price: BigDecimal
    price_gt: BigDecimal
    price_gte: BigDecimal
    price_in: [BigDecimal!]
    price_lt: BigDecimal
    price_lte: BigDecimal
    price_not: BigDecimal
    price_not_in: [BigDecimal!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: String
    to_contains: String
    to_contains_nocase: String
    to_ends_with: String
    to_ends_with_nocase: String
    to_gt: String
    to_gte: String
    to_in: [String!]
    to_lt: String
    to_lte: String
    to_not: String
    to_not_contains: String
    to_not_contains_nocase: String
    to_not_ends_with: String
    to_not_ends_with_nocase: String
    to_not_in: [String!]
    to_not_starts_with: String
    to_not_starts_with_nocase: String
    to_starts_with: String
    to_starts_with_nocase: String
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input TotalSupplyHistoryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TotalSupplyHistoryEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TotalSupplyHistoryEntity_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    totalSupply: BigInt
    totalSupply_gt: BigInt
    totalSupply_gte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_lt: BigInt
    totalSupply_lte: BigInt
    totalSupply_not: BigInt
    totalSupply_not_in: [BigInt!]
}

input TotalTxStatisticEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TotalTxStatisticEntity_filter]
    count: Int
    count_gt: Int
    count_gte: Int
    count_in: [Int!]
    count_lt: Int
    count_lte: Int
    count_not: Int
    count_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TotalTxStatisticEntity_filter]
}

input TreasuryEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TreasuryEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TreasuryEntity_filter]
    tokens_: TreasuryTokenEntity_filter
}

input TreasuryTokenEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TreasuryTokenEntity_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TreasuryTokenEntity_filter]
    token: String
    token_: TokenAmountEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    treasury: String
    treasury_: TreasuryEntity_filter
    treasury_contains: String
    treasury_contains_nocase: String
    treasury_ends_with: String
    treasury_ends_with_nocase: String
    treasury_gt: String
    treasury_gte: String
    treasury_in: [String!]
    treasury_lt: String
    treasury_lte: String
    treasury_not: String
    treasury_not_contains: String
    treasury_not_contains_nocase: String
    treasury_not_ends_with: String
    treasury_not_ends_with_nocase: String
    treasury_not_in: [String!]
    treasury_not_starts_with: String
    treasury_not_starts_with_nocase: String
    treasury_starts_with: String
    treasury_starts_with_nocase: String
}

input TreasuryTokenInfoEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TreasuryTokenInfoEntity_filter]
    controller: String
    controller_: ControllerEntity_filter
    controller_contains: String
    controller_contains_nocase: String
    controller_ends_with: String
    controller_ends_with_nocase: String
    controller_gt: String
    controller_gte: String
    controller_in: [String!]
    controller_lt: String
    controller_lte: String
    controller_not: String
    controller_not_contains: String
    controller_not_contains_nocase: String
    controller_not_ends_with: String
    controller_not_ends_with_nocase: String
    controller_not_in: [String!]
    controller_not_starts_with: String
    controller_not_starts_with_nocase: String
    controller_starts_with: String
    controller_starts_with_nocase: String
    customMinLevel: Int
    customMinLevel_gt: Int
    customMinLevel_gte: Int
    customMinLevel_in: [Int!]
    customMinLevel_lt: Int
    customMinLevel_lte: Int
    customMinLevel_not: Int
    customMinLevel_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TreasuryTokenInfoEntity_filter]
    token: String
    token_: TokenEntity_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    valid: Boolean
    valid_in: [Boolean!]
    valid_not: Boolean
    valid_not_in: [Boolean!]
}

input UserEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserEntity_filter]
    heroes_: HeroEntity_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    itemActions_: ItemActionEntity_filter
    items_: ItemEntity_filter
    lastActionBlock: Int
    lastActionBlock_gt: Int
    lastActionBlock_gte: Int
    lastActionBlock_in: [Int!]
    lastActionBlock_lt: Int
    lastActionBlock_lte: Int
    lastActionBlock_not: Int
    lastActionBlock_not_in: [Int!]
    lastActionTs: Int
    lastActionTs_gt: Int
    lastActionTs_gte: Int
    lastActionTs_in: [Int!]
    lastActionTs_lt: Int
    lastActionTs_lte: Int
    lastActionTs_not: Int
    lastActionTs_not_in: [Int!]
    or: [UserEntity_filter]
    pawnshopActions_: PawnshopPositionHistoryEntity_filter
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    userStat: String
    userStat_: UserStatEntity_filter
    userStat_contains: String
    userStat_contains_nocase: String
    userStat_ends_with: String
    userStat_ends_with_nocase: String
    userStat_gt: String
    userStat_gte: String
    userStat_in: [String!]
    userStat_lt: String
    userStat_lte: String
    userStat_not: String
    userStat_not_contains: String
    userStat_not_contains_nocase: String
    userStat_not_ends_with: String
    userStat_not_ends_with_nocase: String
    userStat_not_in: [String!]
    userStat_not_starts_with: String
    userStat_not_starts_with_nocase: String
    userStat_starts_with: String
    userStat_starts_with_nocase: String
}

input UserStatEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions: Int
    actions_gt: Int
    actions_gte: Int
    actions_in: [Int!]
    actions_lt: Int
    actions_lte: Int
    actions_not: Int
    actions_not_in: [Int!]
    and: [UserStatEntity_filter]
    earned: BigInt
    earned_gt: BigInt
    earned_gte: BigInt
    earned_in: [BigInt!]
    earned_lt: BigInt
    earned_lte: BigInt
    earned_not: BigInt
    earned_not_in: [BigInt!]
    heroMaxLvl: Int
    heroMaxLvl_gt: Int
    heroMaxLvl_gte: Int
    heroMaxLvl_in: [Int!]
    heroMaxLvl_lt: Int
    heroMaxLvl_lte: Int
    heroMaxLvl_not: Int
    heroMaxLvl_not_in: [Int!]
    heroes: Int
    heroes_gt: Int
    heroes_gte: Int
    heroes_in: [Int!]
    heroes_lt: Int
    heroes_lte: Int
    heroes_not: Int
    heroes_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    items: Int
    items_gt: Int
    items_gte: Int
    items_in: [Int!]
    items_lt: Int
    items_lte: Int
    items_not: Int
    items_not_in: [Int!]
    or: [UserStatEntity_filter]
    pawnshopActions: Int
    pawnshopActions_gt: Int
    pawnshopActions_gte: Int
    pawnshopActions_in: [Int!]
    pawnshopActions_lt: Int
    pawnshopActions_lte: Int
    pawnshopActions_not: Int
    pawnshopActions_not_in: [Int!]
    user: String
    user_: UserEntity_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}
